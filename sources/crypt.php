<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2018

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Do a hashing, with support for our "ratcheting up" algorithm (i.e. lets the admin increase the complexity over the time, as CPU speeds get faster).
 *
 * @param  SHORT_TEXT $password The password in plain text
 * @param  SHORT_TEXT $salt The salt
 * @return SHORT_TEXT The salted&hashed password
 */
function ratchet_hash($password, $salt)
{
    // NB: We don't pass the salt separately, we let password_hash generate its own internal salt also (that builds into the hash). So it is double salted.
    $ratchet = max(10, intval(get_option('crypt_ratchet')));
    return password_hash($salt . md5($password), PASSWORD_BCRYPT, array('cost' => $ratchet));
}

/**
 * Verify a password is correct by comparison of the hashed version.
 *
 * @param  SHORT_TEXT $password The password in plain text
 * @param  SHORT_TEXT $salt The salt
 * @param  SHORT_TEXT $pass_hash_salted The prior salted&hashed password, which will also include the algorithm/ratcheting level (unless it's old style, in which case we use non-ratcheted md5)
 * @param  integer $legacy_style Legacy hashing style to fallback to
 * @return boolean Whether the password if verified
 */
function ratchet_hash_verify($password, $salt, $pass_hash_salted, $legacy_style = 0)
{
    if (strpos($pass_hash_salted, '$') !== false) {
        return password_verify($salt . md5($password), $pass_hash_salted);
    }

    // LEGACY: Old-style md5'd password
    if ($legacy_style == PASSWORD_SALT) {
        return hash_equals($pass_hash_salted, md5($password . $salt));
    }
    return hash_equals($pass_hash_salted, md5($salt . md5($password)));
}

/**
 * Get the site-wide salt. It should be something hard for a hacker to get, so we depend on data gathered both from the database and file-system.
 *
 * @return ID_TEXT The salt
 */
function get_site_salt()
{
    $site_salt = get_value('site_salt');
    if ($site_salt === null) {
        $site_salt = get_secure_random_string();
        set_value('site_salt', $site_salt);
    }
    return md5($site_salt);
}

/**
 * Get a randomised string acceptable for use as passwords, tokens, etc.
 * Will be 13 bytes long and base64.
 *
 * @return string The randomised password
 */
function get_secure_random_string()
{
    // md5 used in all the below so that we get nice ASCII characters

    // LEGACY

    if (function_exists('random_bytes')) {
        $string = substr(md5(random_bytes(13)), 0, 13);

    } elseif (function_exists('openssl_random_pseudo_bytes')) {
        $string = substr(md5(openssl_random_pseudo_bytes(13)), 0, 13);

    } elseif (function_exists('password_hash')) { // password_hash will include a randomised component
        $ratchet = max(10, function_exists('crypt_ratchet') ? intval(get_option('crypt_ratchet')) : 3);
        return substr(md5(password_hash(uniqid('', true), PASSWORD_BCRYPT, array('cost' => $ratchet))), 0, 13);

    } else {
        $string = substr(md5(uniqid(strval(get_secure_random_number()), true)), 0, 13);
    }

    return $string;
}

/**
 * Get a secure random number, the best this PHP version can do.
 * Will be between 1 and max signed 32 bit integer (so it can be stored in a 32 bit database).
 *
 * @return integer The randomised number
 */
function get_secure_random_number()
{
    // LEGACY

    do {
        // TODO: #3046 in tracker
        // 2147483647 is from MySQL limit http://dev.mysql.com/doc/refman/5.6/en/integer-types.html ; PHP_INT_MAX is higher on 64bit machines
        if (function_exists('random_int')) {
            $number = random_int(1, 2147483647);

        } elseif (function_exists('openssl_random_pseudo_bytes')) {
            $number = intval(2147483647 * (hexdec(bin2hex(openssl_random_pseudo_bytes(4))) / 0xffffffff));
            if ($number < 0) {
                $number = -$number;
            }

        } elseif (function_exists('password_hash')) { // password_hash will include a randomised component
            $ratchet = max(10, intval(get_option('crypt_ratchet')));
            $hash = password_hash(uniqid('', true), PASSWORD_BCRYPT, array('cost' => $ratchet));
            return crc32($hash);

        } else {
            $number = mt_rand(1, min(2147483647, mt_getrandmax()));
        }
    }
    while ($number <= 0);

    return $number;
}

/**
 * Get obfuscate version of 'mailto:' (which will hopefully fool e-mail scavengers to not pick up these e-mail addresses).
 *
 * @return string The obfuscated 'mailto:' string
 */
function mailto_obfuscated()
{
    static $ret = null;
    if ($ret === null) {
        $ret = 'm' . obfuscate_entities('ailto:');
    }
    return $ret;
}

/**
 * Obfuscate the given text using HTML entity encoding.
 *
 * @param  string $val The text to obfuscate
 * @return string The obfuscated version
 */
function obfuscate_entities($val)
{
    if (strpos($val, '&') !== false) {
        return $val; // Prevent double encoding
    }

    $out = '';
    for ($i = 0; $i < strlen($val); $i++) {
        $char = $val[$i];
        if ($char == '<') {
            $_char = '&lt;';
        } elseif ($char == '>') {
            $_char = '&gt;';
        } elseif ($char == '&') {
            $_char = '&amp;';
        } elseif ($i % 2 == 0) {
            $_char = '&#' . strval(ord($char)) . ';';
        } else {
            $_char = '&#x' . dechex(ord($char)) . ';';
        }

        $out .= $_char;
    }
    if ($GLOBALS['XSS_DETECT']) {
        ocp_mark_as_escaped($out);
    }
    return $out;
}

/**
 * Obfuscate the given e-mail address.
 * This function may want to be modified on a per-site basis, to stop spammers triggering onto Composr's default method (possible some already do, although I think it unlikely they would go to this much effort/computation unless it was more widespread to do this).
 *
 * @param  EMAIL $email The e-mail address to obfuscate
 * @return string The obfuscated version
 */
function obfuscate_email_address($email)
{
    /* One possibility (conventional, but annoying)...
    $i = mt_rand(0, strlen($email));
    $rep = '^remove_me^';
    return substr($email, 0, $i) . $rep . substr($email, $i);
    */

    /* One possibility (conventional, but annoying)...
    $at_pos = strpos($email, '@');
    return substr($email, 0, $at_pos) . 'AT' . substr($email, $at_pos + 1);
    */

    /* Randomly mutated e-mail addresses, so that we can block e-mail address mutations that have become spammed. This would be for webmasters who have default mail for the domain forwarded to themselves.
    $at_pos = strpos($email, '@');
    return substr($email, 0, $at_pos) . mt_rand(0, mt_getrandmax()) . substr($email, $at_pos);
    */

    /* Another possibility would be to write some JavaScript that scans the page after loading, and re-write algorithmically mangled addresses. (You'd need to write some JavaScript to match this, we haven't)
    $remap = array('a' => 'alpha',
                   'b' => 'beta',
                   'c' => 'no',
                   'd' => 'delta',
                   'e' => 'epsilon',
                   'f' => 'more',
                   'g' => 'gamma',
                   'h' => 'eta',
                   'i' => 'iota',
                   'j' => 'letters',
                   'k' => 'kappa',
                   'l' => 'lambda',
                   'm' => 'mu',
                   'n' => 'nu',
                   'o' => 'omicron',
                   'p' => 'pi',
                   'q' => 'xi',
                   'r' => 'rho',
                   's' => 'psi',
                   't' => 'tau',
                   'u' => 'theta',
                   'v' => 'sigma',
                   'w' => 'phi',
                   'x' => 'chi',
                   'y' => 'upsilon',
                   'z' => 'zeta',
    );
    $out = '';
    for ($i = 0; $i < strlen($email)) {
        $at = $email[$i];
        $out .= (array_key_exists($at, $remap)) ? ('{' . $remap[$at] . '}') : $at;
    }
    return $out;
    */

    return obfuscate_entities($email);
}
