<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2018

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*EXTRA FUNCTIONS: shell_exec|fsockopen|ctype_xdigit|curl_.**/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__http()
{
    global $DOWNLOAD_LEVEL;
    $DOWNLOAD_LEVEL = 0;
}

/**
 * Call a function, with inbuilt on-disk caching support.
 *
 * @param  string $func Function to call
 * @param  array $args Arguments to call with
 * @param  ?integer $timeout Caching timeout in minutes (null: no timeout)
 * @return mixed The function result OR for cms_http_request calls a tuple of result details
 */
function cache_and_carry($func, $args, $timeout = null)
{
    $ret = mixed();

    $path = get_custom_file_base() . '/caches/http/' . md5(serialize($args)) . '.dat';
    if (is_file($path) && (($timeout === null) || (filemtime($path) > time() - $timeout * 60))) {
        $_ret = cms_file_get_contents_safe($path);
        if ($func == 'cms_http_request') {
            $ret = @unserialize($_ret);
        } else {
            $ret = $_ret;
        }
    } else {
        $_ret = call_user_func_array($func, $args);
        require_code('files');
        if ($func == 'cms_http_request') {
            $ret = array($_ret->data, $_ret->download_mime_type, $_ret->download_size, $_ret->download_url, $_ret->message, $_ret->message_b, $_ret->new_cookies, $_ret->filename, $_ret->charset, $_ret->download_mtime);
            if ($_ret->data !== null) {
                cms_file_put_contents_safe($path, serialize($ret), FILE_WRITE_FAILURE_SOFT | FILE_WRITE_FIX_PERMISSIONS);
            }
        } else {
            $ret = is_string($_ret) ? $_ret : serialize($_ret);
            cms_file_put_contents_safe($path, $ret, FILE_WRITE_FAILURE_SOFT | FILE_WRITE_FIX_PERMISSIONS);
        }
    }
    return $ret;
}

/**
 * Extract meta details from a URL.
 *
 * @param  URLPATH $url Webpage URL
 * @return array A map of meta details extracted from the webpage
 */
function get_webpage_meta_details($url)
{
    static $cache = array();

    if (array_key_exists($url, $cache)) {
        return $cache[$url];
    }
    if (get_param_integer('keep_oembed_cache', 1) == 1) {
        $_meta_details = $GLOBALS['SITE_DB']->query_select('url_title_cache', array('*'), array('t_url' => $url), '', 1);
        if (array_key_exists(0, $_meta_details)) {
            $meta_details = $_meta_details[0];
            $cache[$url] = $meta_details;
            return $meta_details;
        }
    }

    $meta_details = array(
        't_url' => substr($url, 0, 255),
        't_title' => '',
        't_meta_title' => '',
        't_keywords' => '',
        't_description' => '',
        't_image_url' => '',
        't_mime_type' => '',
        't_json_discovery' => '',
        't_xml_discovery' => '',
    );

    if (url_is_local($url)) {
        $url = get_custom_base_url() . '/' . $url;
    }

    if (!looks_like_url($url)) {
        return $meta_details;
    }

    $result = cache_and_carry('cms_http_request', array($url, array('byte_limit' => 1024 * 10, 'trigger_error' => false, 'timeout' => 2.0)));
    if ((is_array($result)) && ($result[1] !== null) && (strpos($result[1], 'html') !== false) && $result[4] == '200') {
        $html = $result[0];

        // In ascending precedence
        $headers = array(
            't_title' => array(
                '<title[^>]*>\s*(.*)\s*</title>',
            ),
            't_meta_title' => array(
                '<meta\s+name="DC\.Title"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="twitter:title"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="og:title"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+property="og:title"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+property="og:title"\s+name="og:title"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="og:title"\s+property="og:title"\s+content="([^"<>]*)"[^<>]*>',

                '<meta\s+name=\'DC\.Title\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'twitter:title\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'og:title\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+property=\'og:title\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+property=\'og:title\'\s+name=\'og:title\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'og:title\'\s+property=\'og:title\'\s+content=\'([^\'<>]*)\'[^<>]*>',
            ),
            't_keywords' => array(
                '<meta\s+name="keywords"\s+content="([^"<>]*)"[^<>]*>',

                '<meta\s+name=\'keywords\'\s+content=\'([^\'<>]*)\'[^<>]*>',
            ),
            't_description' => array(
                '<meta\s+name="description"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="DC\.Description"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="twitter:description"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="og:description"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+property="og:description"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+property="og:description"\s+name="og:description"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+name="og:description"\s+property="og:description"\s+content="([^"<>]*)"[^<>]*>',

                '<meta\s+name=\'description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'DC\.Description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'twitter:description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'og:description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+property=\'og:description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+property=\'og:description\'\s+name=\'og:description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+name=\'og:description\'\s+property=\'og:description\'\s+content=\'([^\'<>]*)\'[^<>]*>',
            ),
            't_image_url' => array(
                '<meta\s+name="twitter:image"\s+content="([^"<>]*)"[^<>]*>',
                '<meta\s+property="og:image"\s+content="([^"]*)"[^<>]*>',
                '<meta\s+property="og:image"\s+name="og:image"\s+content="([^"]*)"[^<>]*>',
                '<meta\s+name="og:image"\s+property="og:image"\s+content="([^"]*)"[^<>]*>',

                '<meta\s+name=\'twitter:image\'\s+content=\'([^\'<>]*)\'[^<>]*>',
                '<meta\s+property=\'og:image\'\s+content=\'([^\']*)\'[^<>]*>',
                '<meta\s+property=\'og:image\'\s+name=\'og:image\'\s+content=\'([^\']*)\'[^<>]*>',
                '<meta\s+name=\'og:image\'\s+property=\'og:image\'\s+content=\'([^\']*)\'[^<>]*>',
            ),
        );

        require_code('character_sets');
        $html = convert_to_internal_encoding($html, $result[8]);

        foreach ($headers as $header => $regexps) {
            foreach ($regexps as $regexp) {
                $matches = array();
                if (preg_match('#' . $regexp . '#isU', $html, $matches) != 0) {
                    $value = str_replace('"', '&quot;', stripslashes($matches[1]));

                    if ($header == 't_title' || $header == 't_image_url') { // Non-HTML
                        $value = str_replace(array('&ndash;', '&mdash;'), array('-', '-'), $value);
                        $value = @html_entity_decode($value, ENT_QUOTES);
                        $value = trim($value);
                        $value = substr($value, 0, 255);
                    }

                    if ($value != '') {
                        $meta_details[$header] = $value;
                    }
                }
            }
        }

        if ($meta_details['t_image_url'] != '') {
            if (strlen($meta_details['t_image_url']) > 255) {
                $meta_details['t_image_url'] = ''; // We can't deal with really long URLs here
            }
        }

        if (($result[1] == 'application/octet-stream') || ($result[1] == '')) {
            // Lame, no real mime type - maybe the server is just not configured to know it - try and guess by using the file extension and our own Composr list
            require_code('mime_types');
            require_code('files');
            $meta_details['t_mime_type'] = get_mime_type(get_file_extension($url), true);
        } else {
            $meta_details['t_mime_type'] = $result[1];
        }

        $matches = array();
        $num_matches = preg_match_all('#<link\s+[^<>]*>#i', $html, $matches);
        for ($i = 0; $i < $num_matches; $i++) {
            $line = $matches[0][$i];
            $matches2 = array();
            if ((preg_match('#\srel=["\']?alternate["\']?#i', $line) != 0) && (preg_match('#\shref=["\']?([^"\']+)["\']?#i', $line, $matches2) != 0)) {
                if (preg_match('#\stype=["\']?application/json\+oembed["\']?#i', $line) != 0) {
                    $meta_details['t_json_discovery'] = @html_entity_decode($matches2[1], ENT_QUOTES);
                    if (strlen($meta_details['t_json_discovery']) > 255) {
                        $meta_details['t_json_discovery'] = ''; // We can't deal with really long URLs here
                    }
                }
                if (preg_match('#\stype=["\']?text/xml\+oembed["\']?#i', $line) != 0) {
                    $meta_details['t_xml_discovery'] = @html_entity_decode($matches2[1], ENT_QUOTES);
                    if (strlen($meta_details['t_xml_discovery']) > 255) {
                        $meta_details['t_xml_discovery'] = ''; // We can't deal with really long URLs here
                    }
                }
            }
        }

        $GLOBALS['SITE_DB']->query_insert('url_title_cache', $meta_details, false, true); // 'true' to stop race conditions
    } elseif (is_array($result)) {
        $meta_details['t_mime_type'] = $result[1];
    }

    $cache[$url] = $meta_details;
    return $meta_details;
}

/**
 * Return the file in the URL by downloading it over HTTP. If a byte limit is given, it will only download that many bytes. It outputs warnings, returning null, on error.
 *
 * @param  URLPATH $url The URL to download
 * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
 * @return object HttpDownloader object, which can be checked for return data
 */
function _cms_http_request($url, $options = array())
{
    $curl = new HttpDownloaderCurl();
    $curl_priority = $curl->may_run_for($url, $options);

    $sockets = new HttpDownloaderSockets();
    $sockets_priority = $sockets->may_run_for($url, $options);

    $file_wrapper = new HttpDownloaderFileWrapper();
    $file_wrapper_priority = $file_wrapper->may_run_for($url, $options);

    $filesystem = new HttpDownloaderFilesystem();
    $filesystem_priority = $filesystem->may_run_for($url, $options);

    if ($curl_priority > $sockets_priority && $curl_priority > $file_wrapper_priority && $curl_priority > $filesystem_priority) {
        $curl->run($url, $options);
        return $curl;
    } elseif ($sockets_priority > $file_wrapper_priority && $sockets_priority > $filesystem_priority) {
        $sockets->run($url, $options);
        return $sockets;
    } elseif ($file_wrapper_priority > $filesystem_priority) {
        $file_wrapper->run($url, $options);
        return $file_wrapper;
    }
    $filesystem->run($url, $options);
    return $filesystem;
}

/**
 * Base HttpDownloader.
 *
 * @package    core
 */
abstract class HttpDownloader
{
    // Run priorities
    const RUN_PRIORITY_NO = 1;
    const RUN_PRIORITY_LOW = 2;
    const RUN_PRIORITY_MEDIUM = 3;
    const RUN_PRIORITY_HIGH = 4;
    const RUN_PRIORITY_VERY_HIGH = 5;

    // Input parameters, coming from $options map
    protected $byte_limit = null; // ?integer. The number of bytes to download. This is not a guarantee, it is a minimum (null: all bytes)
    protected $trigger_error = true; // boolean. Whether to throw a Composr error, on error
    protected $no_redirect = false; // boolean. Whether to block redirects (returns null when found)
    protected $ua = 'Composr'; // ~?string. The user-agent to identify as (null: simulate Google Chrome) (false: none, useful to avoid filtering rules on the other end)
    protected $post_params = null; // ?array. An optional array of POST parameters to send; if this is null, a GET request is used (null: none). If $raw_post is set, it should be array($data)
    protected $cookies = array(); // array. An optional array of cookies to send
    protected $accept = null; // ?string. 'accept' header value (null: don't pass one)
    protected $accept_charset = null; // ?string. 'accept-charset' header value (null: don't pass one)
    protected $accept_language = null; // ?string. 'accept-language' header value (null: don't pass one)
    protected $write_to_file = null; // ?resource. File handle to write to (null: do not do that)
    protected $referer = null; // ?string. The HTTP referer (null: none)
    protected $auth = null; // ?array. A pair: authentication username and password (null: none)
    protected $timeout = 6.0; // float. The timeout
    protected $raw_post = false; // boolean. Whether to treat the POST parameters as a raw POST (rather than using MIME)
    protected $files = array(); // array. Files to send. Map between field name to file path
    protected $extra_headers = array(); // array. Extra headers to send
    protected $http_verb = null; // ?string. HTTP verb (null: auto-decide based on other parameters)
    protected $raw_content_type = 'application/xml'; // string. The content type to use if a raw HTTP post
    protected $ignore_http_status = false; // boolean. Return a result regardless of HTTP status
    protected $verifypeer_enabled = true; // boolean. Whether to check SSL certificates

    // Class processing configuration
    protected $add_content_type_header_manually = false;
    protected $add_files_manually = false;

    // Internal
    protected $divider = null;
    protected $url_parts = null;
    protected $connect_to = null;
    protected $do_ip_forwarding = null;
    protected $connecting_url = null;
    protected $raw_payload = null;
    protected $sent_http_post_content = false;
    protected $put = null;
    protected $put_path = null;
    protected $put_no_delete = null;

    // Output
    public $data = null; // ?string. The result returned from the last HTTP lookup.
    public $download_mime_type = null; // ?ID_TEXT. The mime type returned from the last HTTP lookup.
    public $download_size = null; // ?ID_TEXT. The download size returned from the last HTTP lookup.
    public $download_url = null; // ?ID_TEXT. The URL for the last HTTP lookup.
    public $download_mtime = null; // ?ID_TEXT. The file modification time returned from the last HTTP lookup.
    public $message = null; // string. The status code returned from the last HTTP lookup (e.g. "200" or "404").
    public $message_b = null; // string. The status messagereturned from the last HTTP lookup.
    public $new_cookies = array(); // ?ID_TEXT. The cookies returned from the last HTTP lookup.
    public $filename = null; // ?ID_TEXT. The filename returned from the last HTTP lookup.
    public $charset = null; // ?ID_TEXT. The character set returned from the last HTTP lookup.
    public $headers = array(); // Any HTTP headers collected.
    public $implementation_used = null; // For debugging.

    /**
     * See if this class may run.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return integer The execution priority
     */
    abstract public function may_run_for($url, $options = array());

    /**
     * Return the file in the URL by downloading it over HTTP. If a byte limit is given, it will only download that many bytes. It outputs warnings, returning null, on error.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     */
    public function run($url, $options = array())
    {
        global $DOWNLOAD_LEVEL;

        $this->implementation_used = get_class($this);

        $this->download_url = $url;

        // Parse options...

        $this->read_in_options($options);

        // Prevent DOS loop attack...

        if ($_SERVER['HTTP_USER_AGENT'] == $this->ua) {
            $ua = 'Composr-recurse';
        }
        if ($_SERVER['HTTP_USER_AGENT'] == 'Composr-recurse') {
            return;
        }
        if ($DOWNLOAD_LEVEL == 8) {
            $this->data = null;
            return;
        }

        // Normalise the URL...

        require_code('urls');
        $url = str_replace(' ', '%20', $url);
        if (url_is_local($url)) {
            $url = get_custom_base_url() . '/' . $url;
        }
        if ((strpos($url, '/') !== false) && (strrpos($url, '/') < 7)) {
            $url .= '/';
        }

        // HTTP authentication in URL
        if ($this->auth === null) {
            $matches = array();
            if (preg_match('#^https?://([^:@/]+):([^:@/]+)@#', $url, $matches) != 0) {
                $this->auth = array($matches[1], $matches[2]);
            }
        }

        // Work out what we'll be connecting to...

        $this->url_parts = @parse_url(normalise_idn_url($url));
        if (($this->url_parts === false) || (!isset($this->url_parts['host'])) || (!isset($this->url_parts['scheme']))) {
            if ($this->trigger_error) {
                warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_BAD_URL', escape_html($url)), false, true);
            } else {
                $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_BAD_URL', escape_html($url));
            }
            $DOWNLOAD_LEVEL--;
            $this->message = 'malconstructed-URL';
            return null;
        }
        if (!array_key_exists('host', $this->url_parts)) {
            $this->url_parts['host'] = '127.0.0.1';
        }
        $this->connect_to = $this->url_parts['host'];

        $base_url_parsed = parse_url(get_base_url());
        if (!array_key_exists('host', $base_url_parsed)) {
            $base_url_parsed['host'] = '127.0.0.1';
        }

        $config_ip_forwarding = function_exists('get_option') ? get_option('ip_forwarding') : '';
        $this->do_ip_forwarding = (preg_replace('#^www\.#', '', $base_url_parsed['host']) == preg_replace('#^www\.#', '', $this->connect_to)) && ($config_ip_forwarding != '') && ($config_ip_forwarding != '0');

        if ($this->do_ip_forwarding) { // For cases where we have IP-forwarding, and a strong firewall (i.e. blocked to our own domain's IP by default)
            if ($config_ip_forwarding == '1') {
                $this->connect_to = $_SERVER['SERVER_ADDR'];
                if ($this->connect_to == '') {
                    $this->connect_to = '127.0.0.1'; // "localhost" can fail due to IP6
                }
            } else {
                $protocol_end_pos = strpos($config_ip_forwarding, '://');
                if ($protocol_end_pos !== false) {
                    // Full with protocol
                    $url = preg_replace('#^(https?://)#', substr($config_ip_forwarding, 0, $protocol_end_pos + 3), $url);
                    $config_ip_forwarding = substr($config_ip_forwarding, $protocol_end_pos + 3);
                } else {
                    // IP address
                }
                $this->connect_to = $config_ip_forwarding;
            }
        } elseif ($this->url_parts['scheme'] == 'http') {
            $this->connect_to = cms_gethostbyname($this->connect_to); // for DNS caching
        }
        if (!array_key_exists('scheme', $this->url_parts)) {
            $this->url_parts['scheme'] = 'http';
        }

        if (strpos($this->connect_to, ':') !== false) {
            $connect_to_url_compat = '[' . $this->connect_to . ']';
        } else {
            $connect_to_url_compat = $this->connect_to;
        }
        $this->connecting_url = preg_replace('#^(https?://)' . preg_quote($this->url_parts['host'], '#') . '([/:]|$)#', '${1}' . $connect_to_url_compat . '${2}', $url);

        // More preprocessing...

        $this->raw_payload = ''; // Note that this will contain HTTP headers (it is appended directly after headers with no \r\n between -- so it contains \r\n\r\n itself when the content body is going to start)
        $this->sent_http_post_content = false;
        $this->put = null;
        $this->put_path = null;
        $this->put_no_delete = false;
        if (($this->post_params !== null) || ($this->raw_post) || ($this->files != array())) {
            if ($this->post_params === null) {
                $this->post_params = array(); // POST is implied
            }

            if ($this->raw_post) {
                $_postdetails_params = $this->post_params[0];
            } else {
                $_postdetails_params = '';//$this->url_parts['scheme'] . '://' . $this->url_parts['host'] . $url2 . '?';
                if (array_keys($this->post_params) === array('_')) {
                    $_postdetails_params = $this->post_params['_'];
                } else {
                    if (count($this->post_params) > 0) {
                        $_postdetails_params .= http_build_query($this->post_params);
                    }
                }
            }

            if ($this->files == array()) { // If no files, use simple application/x-www-form-urlencoded
                if (!$this->add_content_type_header_manually) {
                    if ($this->raw_post) {
                        if (!isset($this->extra_headers['Content-Type'])) {
                            $this->raw_payload .= 'Content-Type: ' . $this->raw_content_type . "\r\n";
                        }
                    } else {
                        $this->raw_payload .= 'Content-Type: application/x-www-form-urlencoded; charset=' . get_charset() . "\r\n";
                    }
                    $this->raw_payload .= 'Content-Length: ' . strval(strlen($_postdetails_params)) . "\r\n";
                    $this->raw_payload .= "\r\n";
                } // curl sets the above itself
                $this->raw_payload .= $_postdetails_params;
                if (!$this->add_content_type_header_manually) {
                    $this->raw_payload .= "\r\n\r\n";
                }
                $this->sent_http_post_content = true;
            } else { // If files, use more complex multipart/form-data
                if (strtolower($this->http_verb) == 'put') {
                    $this->put_no_delete = (count($this->post_params) == 0) && (count($this->files) == 1); // Can we just use the one referenced file as a direct PUT
                    if ($this->put_no_delete) { // Yes
                        reset($this->files);
                        $this->put_path = current($this->files);
                        $this->put = fopen($this->put_path, 'rb');
                    } else { // No, we need to spool out HTTP blah to make a new file to PUT
                        $this->put_path = cms_tempnam();
                        $this->put = fopen($this->put_path, 'wb');
                    }
                }

                $this->divider = uniqid('', true);
                $raw_payload2 = '';
                if (($this->put === null) || (count($this->post_params) != 0) || (count($this->files) != 0)) {
                    $this->raw_payload .= 'Content-Type: multipart/form-data; boundary="--cms' . $this->divider . '"; charset=' . get_charset() . "\r\n";
                }
                foreach ($this->post_params as $key => $val) {
                    $raw_payload2 .= '----cms' . $this->divider . "\r\n";
                    if ($this->raw_post) {
                        if (!isset($this->extra_headers['Content-Type'])) {
                            $raw_payload2 .= 'Content-Type: ' . $this->raw_content_type . "\r\n\r\n";
                        }
                    } else {
                        $raw_payload2 .= 'Content-Disposition: form-data; name="' . urlencode($key) . '"' . "\r\n\r\n";
                    }
                    $raw_payload2 .= $val . "\r\n";
                }
                if (($this->put !== null) && (!$this->put_no_delete)) {
                    fwrite($this->put, $raw_payload2);
                    $raw_payload2 = '';
                }
                foreach ($this->files as $upload_field => $file_path) {
                    if (($this->put === null) || (count($this->post_params) != 0) || (count($this->files) != 1)) {
                        $raw_payload2 .= '----cms' . $this->divider . "\r\n";
                        if (strpos($upload_field, '/') === false) {
                            $raw_payload2 .= 'Content-Disposition: form-data; name="' . str_replace('"', '\"', $upload_field) . '"; filename="' . urlencode(basename($file_path)) . '"' . "\r\n";

                            require_code('mime_types');
                            require_code('files');
                            $raw_payload2 .= 'Content-Type: ' . get_mime_type(get_file_extension($file_path), true) . "; charset=" . get_charset() . "\r\n\r\n";
                        } else {
                            // mime-type given rather than file-name
                            $raw_payload2 .= 'Content-Type: ' . $upload_field . "\r\n\r\n";
                        }
                    } else {
                        if ((strpos($upload_field, '/') === false) && ($this->raw_content_type == '')) {
                            $this->raw_content_type = $upload_field;
                        }
                    }
                    if (($this->put !== null) && (!$this->put_no_delete)) {
                        fwrite($this->put, $raw_payload2);
                        $raw_payload2 = '';
                    }
                    if (($this->put !== null) && (!$this->put_no_delete)) {
                        $myfile = fopen($file_path, 'rb');
                        while (!feof($myfile)) {
                            $data = @fread($myfile, 1024 * 100);
                            if (($data !== false) && ($data !== null)) {
                                fwrite($this->put, $data);
                            } else {
                                break;
                            }
                        }
                        @fclose($myfile);
                    } else {
                        $raw_payload2 .= file_get_contents($file_path);
                    }
                    if (($this->put === null) || (count($this->post_params) != 0) || (count($this->files) != 1)) {
                        $raw_payload2 .= "\r\n";
                    }
                    if (($this->put !== null) && (!$this->put_no_delete)) {
                        fwrite($this->put, $raw_payload2);
                        $raw_payload2 = '';
                    }
                }
                if (($this->put === null) || (count($this->post_params) != 0) || (count($this->files) != 1)) {
                    $raw_payload2 .= '----cms' . $this->divider . "--\r\n";
                }
                if (($this->put !== null) && (!$this->put_no_delete)) {
                    fwrite($this->put, $raw_payload2);
                    $raw_payload2 = '';
                }
                if ($this->put !== null) {
                    $this->raw_payload .= 'Content-Length: ' . strval(filesize($this->put_path)) . "\r\n";
                } else {
                    $this->raw_payload .= 'Content-Length: ' . strval(strlen($raw_payload2)) . "\r\n";
                }
                $this->raw_payload .= "\r\n" . $raw_payload2;
                if ($this->add_files_manually) {
                    $this->raw_payload = $raw_payload2; // Other settings will be passed via cURL itself
                }
            }
        }

        if ($this->http_verb === null) {
            $this->http_verb = ((($this->post_params === null) && ($this->files == array())) ? (($this->byte_limit === 0) ? 'HEAD' : 'GET') : 'POST');
        }

        // Call downloader method...

        global $DOWNLOAD_LEVEL;
        $DOWNLOAD_LEVEL++;
        $this->data = $this->_run($url, $options);
        $this->detect_character_encoding();
        $DOWNLOAD_LEVEL--;
    }

    /**
     * Read in options.
     *
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     */
    protected function read_in_options($options)
    {
        if (array_key_exists('byte_limit', $options)) {
            $this->byte_limit = $options['byte_limit'];
        }

        if (array_key_exists('trigger_error', $options)) {
            $this->trigger_error = $options['trigger_error'];
        }

        if (array_key_exists('no_redirect', $options)) {
            $this->no_redirect = $options['no_redirect'];
        }

        if (array_key_exists('ua', $options)) {
            $this->ua = $options['ua'];

            if ($this->ua === null) {
                $this->ua = 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.A.B.C Safari/525.13';
            }
        }

        if (array_key_exists('post_params', $options)) {
            $this->post_params = $options['post_params'];
        }

        if (array_key_exists('cookies', $options)) {
            $this->cookies = $options['cookies'];
        }

        if (array_key_exists('accept', $options)) {
            $this->accept = $options['accept'];
        }

        if (array_key_exists('accept_charset', $options)) {
            $this->accept_charset = $options['accept_charset'];
        }

        if (array_key_exists('accept_language', $options)) {
            $this->accept_language = $options['accept_language'];
        }

        if (array_key_exists('write_to_file', $options)) {
            $this->write_to_file = $options['write_to_file'];
        }

        if (array_key_exists('referer', $options)) {
            $this->referer = $options['referer'];
        }

        if (array_key_exists('auth', $options)) {
            $this->auth = $options['auth'];
        }

        if (array_key_exists('timeout', $options)) {
            $this->timeout = $options['timeout'];
        }

        if (array_key_exists('raw_post', $options)) {
            $this->raw_post = $options['raw_post'];
        }

        if (array_key_exists('files', $options)) {
            $this->files = $options['files'];
        }

        if (array_key_exists('extra_headers', $options)) {
            $this->extra_headers = $options['extra_headers'];
        }

        if (array_key_exists('http_verb', $options)) {
            $this->http_verb = $options['http_verb'];
        }

        if (array_key_exists('raw_content_type', $options)) {
            $this->raw_content_type = $options['raw_content_type'];
        }

        if (array_key_exists('ignore_http_status', $options)) {
            $this->ignore_http_status = $options['ignore_http_status'];
        }

        if (array_key_exists('verifypeer_enabled', $options)) {
            $this->verifypeer_enabled = $options['verifypeer_enabled'];
        }
    }

    /**
     * Do the inner call using a particular downloader method.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return ?string The data downloaded (null: error)
     */
    abstract protected function _run($url, $options);

    /**
     * Find the cookie HTTP header contents.
     *
     * @return string The cookie line
     */
    protected function get_cookie_string()
    {
        // Prep cookies
        if ($this->cookies != array()) {
            $cookies = '';
            $done_one_cookie = false;
            foreach ($this->cookies as $key => $val) {
                if ($done_one_cookie) {
                    $cookies .= '; ';
                }
                if (is_array($val)) {
                    foreach ($val as $key2 => $val2) {
                        if (!is_string($key2)) {
                            $key2 = strval($key2);
                        }
                        if ($done_one_cookie) {
                            $cookies .= '; ';
                        }
                        $cookies .= $key . '[' . $key2 . ']=' . rawurlencode($val2);
                        $done_one_cookie = true;
                    }
                } else {
                    $cookies .= $key . '=' . rawurlencode($val);
                }
                $done_one_cookie = true;
            }
        }
        return $cookies;
    }

    /**
     * Find the HTTP header contents.
     *
     * @return string The header contents
     */
    protected function get_header_string()
    {
        $headers = '';
        if ($this->cookies != array()) {
            $headers .= 'Cookie: ' . $this->get_cookie_string() . "\r\n";
        }
        if (is_string($this->ua)) {
            $headers .= 'User-Agent: ' . rawurlencode($this->ua) . "\r\n";
        }
        if ($this->auth !== null) {
            $headers .= 'Authorization: Basic ' . base64_encode(implode(':', $this->auth)) . "==\r\n";
        }
        foreach ($this->extra_headers as $key => $val) {
            $headers .= $key . ': ' . $val . "\r\n";
        }
        if ($this->accept !== null) {
            $headers .= 'Accept: ' . rawurlencode($this->accept) . "\r\n";
        } else {
            $headers .= "Accept: */*\r\n"; // There's a mod_security rule that checks for this
        }
        if ($this->accept_charset !== null) {
            $headers .= 'Accept-Charset: ' . rawurlencode($this->accept_charset) . "\r\n";
        }
        if ($this->accept_language !== null) {
            $headers .= 'Accept-Language: ' . rawurlencode($this->accept_language) . "\r\n";
        }
        if ($this->referer !== null) {
            $headers .= 'Referer: ' . rawurlencode($this->referer) . "\r\n";
        }
        return $headers;
    }

    /**
     * Read in any HTTP headers that we probe for, from an HTTP line.
     *
     * @param  string $line The line
     */
    protected function read_in_headers($line)
    {
        $matches = array();
        if (preg_match("#Content-Disposition: [^\r\n]*filename=\"([^;\r\n]*)\"\r\n#i", $line, $matches) != 0) {
            $this->filename = $matches[1];
        }
        if (preg_match("#^Set-Cookie: ([^\r\n=]*)=([^\r\n]*)\r\n#i", $line, $matches) != 0) {
            $this->new_cookies[trim(rawurldecode($matches[1]))] = trim($matches[2]);

            $cookie_key = trim(rawurldecode($matches[1]));

            $cookie_value = trim($matches[2]);
            $_cookie_parts = explode('; ', $cookie_value);

            $cookie_parts = array();

            $cookie_parts['key'] = $cookie_key;
            $cookie_parts['value'] = trim(rawurldecode(array_shift($_cookie_parts)));

            foreach ($_cookie_parts as $i => $part) {
                $temp = explode('=', $part, 2);
                if (array_key_exists(1, $temp)) {
                    $cookie_parts[trim($temp[0])] = trim(rawurldecode($temp[1]));
                }
            }
            if (function_exists('get_cookie_domain')) {
                $cookie_parts['domain'] = get_cookie_domain();
            }

            $this->new_cookies[$cookie_key] = $cookie_parts;
        }
        if (preg_match("#^Content-Length: ([^;\r\n]*)\r\n#i", $line, $matches) != 0) {
            $this->download_size = intval($matches[1]);
        }
        if (preg_match("#^Last-Modified: ([^;\r\n]*)\r\n#i", $line, $matches) != 0) {
            $this->download_mtime = strtotime($matches[1]);
        }
        if (preg_match("#^Content-Type: ([^;\r\n]*)(;[^\r\n]*)?\r\n#i", $line, $matches) != 0) {
            $this->download_mime_type = $matches[1];
            if (array_key_exists(2, $matches)) {
                $_ct_more = explode(';', str_replace(' ', '', trim($matches[2])));
                foreach ($_ct_more as $ct_more) {
                    $ct_bits = explode('=', $ct_more, 2);
                    if ((count($ct_bits) == 2) && (strtolower($ct_bits[0]) == 'charset')) {
                        $this->charset = trim($ct_bits[1]);
                    }
                }
            }
        }

        $this->headers[] = $line;
    }

    /**
     * Try a bit harder to detect the character encoding, in case it was not in an HTTP header.
     */
    protected function detect_character_encoding()
    {
        if (($this->charset === null) && ($this->data !== null)) {
            $matches = array();
            if (preg_match('#<' . '?xml[^<>]*\s+encoding="([^"]+)"#', $this->data, $matches) != 0) {
                $this->charset = trim($matches[1]);
            } elseif (preg_match('#<meta\s+http-equiv="Content-Type"\s+content="[^"]*;\s*charset=([^"]+)"#i', $this->data, $matches) != 0) {
                $this->charset = trim($matches[1]);
            }
        }
    }

    /**
     * Copy response metadata from one object to another.
     * Does not copy response data, that is returned as a string.
     *
     * @param  object $from The child response
     * @param  object $to The parent response
     * @return ?string The data downloaded (null: error)
     */
    protected function copy_from_other($from, $to)
    {
        $to->download_mime_type = $from->download_mime_type;
        $to->download_size = $from->download_size;
        $to->download_url = $from->download_url;
        $to->download_mtime = $from->download_mtime;
        $to->message = $from->message;
        $to->message_b = $from->message_b;
        $to->new_cookies = array_merge($to->new_cookies, $from->new_cookies);
        if ($to->filename !== null) {
            $to->filename = $from->filename;
        }
        $to->charset = $from->charset;
        $to->headers = $from->headers;
        $to->implementation_used = $from->implementation_used;

        return $from->data;
    }

    /**
     * Cleanup object.
     */
    public function __destruct()
    {
        // Cleanup
        if ($this->put !== null) {
            fclose($this->put);
        }
        if (!$this->put_no_delete) {
            if ($this->put_path !== null) {
                @unlink($this->put_path);
            }
        }
    }
}

/**
 * cURL-based HttpDownloader.
 *
 * @package    core
 */
class HttpDownloaderCurl extends HttpDownloader
{
    // Class processing configuration
    protected $add_content_type_header_manually = true;
    protected $add_files_manually = true;

    // Data collection
    protected $curl_headers = array();
    protected $curl_body = null;

    /**
     * See if this class may run.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return integer The execution priority
     */
    public function may_run_for($url, $options = array())
    {
        $this->url_parts = @parse_url(normalise_idn_url($url));
        $this->read_in_options($options);

        if (!function_exists('curl_version')) {
            return HttpDownloader::RUN_PRIORITY_NO;
        }

        if ((function_exists('get_value')) && (get_value('prefer_curl') === '0')) {
            return HttpDownloader::RUN_PRIORITY_NO;
        }

        if (isset($this->url_parts['scheme'])) {
            if ($this->url_parts['scheme'] != 'http') {
                $curl_version = curl_version();
                if (((is_string($curl_version)) && (strpos($curl_version, 'OpenSSL') !== false)) || ((is_array($curl_version)) && (array_key_exists('ssl_version', $curl_version)))) {
                    return HttpDownloader::RUN_PRIORITY_HIGH;
                }
            }

            if (($this->url_parts['scheme'] == 'http') && ((function_exists('get_value')) && (get_value('prefer_curl') === '1'))) {
                return HttpDownloader::RUN_PRIORITY_HIGH;
            }
        }

        return HttpDownloader::RUN_PRIORITY_LOW;
    }

    /**
     * Do the inner call using a particular downloader method.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return ?string The data downloaded (null: error)
     */
    protected function _run($url, $options)
    {
        $ch = curl_init($this->do_ip_forwarding ? $this->connecting_url : $url);

        // Cookie prep
        if ($this->cookies != array()) {
            curl_setopt($ch, CURLOPT_COOKIE, $this->get_cookie_string());
        }

        // SSL prep
        $verifypeer_enabled =
            $this->verifypeer_enabled &&
            !$this->do_ip_forwarding &&
            ((!function_exists('get_value')) || (get_value('disable_ssl_for__' . $this->url_parts['host']) === '0'));
        if ($verifypeer_enabled) {
            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);
            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);
        } else {
            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);
            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
        }
        if (ini_get('curl.cainfo') == '') {
            $crt_path = get_file_base() . '/data/curl-ca-bundle.crt';
            curl_setopt($ch, CURLOPT_CAINFO, $crt_path);
        }
        curl_setopt($ch, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1); // https://jve.linuxwall.info/blog/index.php?post/TLS_Survey
        // ^ If you get errors about ciphers not matching up, it's possibly cURL being buggy and misreporting a firewall problem. The above config settings should be rock-solid on almost every single server.

        // Misc settings
        //if (!$this->no_redirect) @curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); // we can do better ourselves anyway and protect against file:// exploits.
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, intval($this->timeout));
        curl_setopt($ch, CURLOPT_TIMEOUT, intval($this->timeout));

        // Request type
        if ($this->http_verb == 'HEAD') {
            curl_setopt($ch, CURLOPT_NOBODY, true); // Branch needed as doing a HEAD via CURLOPT_CUSTOMREQUEST can cause a timeout bug in cURL
        } else {
            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $this->http_verb);
        }

        // Headers
        $curl_headers = array();
        if ($this->accept !== null) {
            $curl_headers[] = 'Accept: ' . $this->accept;
        }
        if ($this->accept_charset !== null) {
            $curl_headers[] = 'Accept-Charset: ' . $this->accept_charset;
        }
        if ($this->accept_language !== null) {
            $curl_headers[] = 'Accept-Language: ' . $this->accept_language;
        }
        foreach ($this->extra_headers as $key => $val) {
            $curl_headers[] = $key . ': ' . $val;
        }
        if (($this->raw_post) && (($this->files == array()) || ($this->put !== null))) {
            if (!isset($this->extra_headers['Content-Type'])) {
                $curl_headers[] = 'Content-Type: ' . $this->raw_content_type;
            }
        }
        if ($this->post_params !== null) {
            if ($this->put !== null) {
                fclose($this->put);
                $this->put = fopen($this->put_path, 'rb');
                curl_setopt($ch, CURLOPT_PUT, true);
                curl_setopt($ch, CURLOPT_INFILE, $this->put);
                curl_setopt($ch, CURLOPT_INFILESIZE, filesize($this->put_path));
            } else {
                curl_setopt($ch, CURLOPT_POST, true);
                curl_setopt($ch, CURLOPT_POSTFIELDS, $this->raw_payload);
                if ($this->files != array()) {
                    $curl_headers[] = 'Content-Type: multipart/form-data; boundary="--cms' . $this->divider . '"; charset=' . get_charset();
                }
            }
        }
        if ($this->do_ip_forwarding) {
            $curl_headers[] = 'Host: ' . $this->url_parts['host'];
        }
        if ((count($curl_headers) != 0) && ((($this->files == array())/*Breaks file uploads for some reason*/) || ($this->extra_headers != array()))) {
            curl_setopt($ch, CURLINFO_HEADER_OUT, true);
            curl_setopt($ch, CURLOPT_HTTPHEADER, $curl_headers);
        }

        // cURL options that will create headers also
        if ($this->auth !== null) {
            curl_setopt($ch, CURLOPT_USERPWD, implode(':', $this->auth));
        }
        if ($this->referer !== null) {
            curl_setopt($ch, CURLOPT_REFERER, $this->referer);
        }
        if (is_string($this->ua)) {
            curl_setopt($ch, CURLOPT_USERAGENT, $this->ua);
        }
        if ($this->byte_limit !== null) {
            curl_setopt($ch, CURLOPT_RANGE, '0-' . strval(($this->byte_limit == 0) ? 0 : ($this->byte_limit - 1)));
        }

        // Proxy settings
        $proxy = function_exists('get_option') ? get_option('proxy') : '';
        if (($proxy != '') && ($this->url_parts['host'] != 'localhost') && ($this->url_parts['host'] != '127.0.0.1')) {
            $port = get_option('proxy_port');
            curl_setopt($ch, CURLOPT_PROXY, $proxy . ':' . $port);
            $proxy_user = get_option('proxy_user');
            if ($proxy_user != '') {
                $proxy_password = get_option('proxy_password');
                curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxy_user . ':' . $proxy_password);
            }
        }

        // Data collection
        curl_setopt($ch, CURLOPT_HEADERFUNCTION, array($this, 'file_curl_headers'));
        curl_setopt($ch, CURLOPT_WRITEFUNCTION, array($this, 'file_curl_body'));

        // Response
        $curl_result = curl_exec($ch);
        /*if ((count($curl_headers)!=0) && (($this->files != array()))) { // Useful for debugging
            var_dump(curl_getinfo($ch,CURLINFO_HEADER_OUT));exit();
        }*/
        if ($curl_result === false) {
            // Error
            $error = curl_error($ch);
            curl_close($ch);

            if ($this->trigger_error) {
                warn_exit(protect_from_escaping($error), false, true);
            } else {
                $this->message_b = protect_from_escaping($error);
            }

            return null;
        }

        // Response metadata that cURL lets us gather easily
        $this->download_mime_type = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
        if ($this->download_mime_type === false) {
            $this->download_mime_type = null;
        }
        $this->download_size = curl_getinfo($ch, CURLINFO_CONTENT_LENGTH_DOWNLOAD);
        $this->download_url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
        if ($this->download_url == $this->connecting_url) {
            $this->download_url = $url;
        }
        $this->message = strval(curl_getinfo($ch, CURLINFO_HTTP_CODE));
        if ($this->message == '206') {
            $this->message = '200'; // We don't care about partial-content return code, as Composr implementation gets ranges differently and we check '200' as a return result
        }
        if (($this->download_mime_type !== null) && (strpos($this->download_mime_type, ';') !== false)) {
            $this->charset = substr($this->download_mime_type, 8 + strpos($this->download_mime_type, 'charset='));
            $this->download_mime_type = substr($this->download_mime_type, 0, strpos($this->download_mime_type, ';'));
        }

        // Process HTTP status
        switch ($this->message) {
            case '200':
            case '201':
            case '301':
            case '302':
            case '307':
                break;

            case '401':
            case '403':
                if (!$this->ignore_http_status) {
                    if ($this->trigger_error) {
                        warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNAUTHORIZED', escape_html($url)), false, true);
                    } else {
                        $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNAUTHORIZED', escape_html($url));
                    }
                }
                break;

            case '404':
                if (!$this->ignore_http_status) {
                    if ($this->trigger_error) {
                        warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_NOT_FOUND', escape_html($url)), false, true);
                    } else {
                        $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_NOT_FOUND', escape_html($url));
                    }
                }
                break;

            case '400':
            case '429':
            case '500':
                if (!$this->ignore_http_status) {
                    if ($this->trigger_error) {
                        warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_SERVER_ERROR', escape_html($url)), false, true);
                    } else {
                        $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_SERVER_ERROR', escape_html($url));
                    }
                }
                break;

            default:
                if (!$this->ignore_http_status) {
                    if ($this->trigger_error) {
                        warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNKNOWN', escape_html($url), escape_html($this->message)), false, true);
                    } else {
                        $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNKNOWN', escape_html($url), escape_html($this->message));
                    }
                }
                break;
        }

        curl_close($ch);

        // Receive headers
        foreach ($this->curl_headers as $header) {
            $matches = array();

            if (preg_match('#^Content-Disposition: [^;]*;\s*filename="([^"]*)"#i', $header, $matches) != 0) {
                $this->read_in_headers($header);
            }

            if (preg_match("#^Set-Cookie: ([^\r\n=]*)=([^\r\n]*)\r\n#i", $header, $matches) != 0) {
                $this->read_in_headers($header);
            }

            if (preg_match("#^Refresh: (\d*);(.*)\r\n#i", $header, $matches) != 0) {
                if ($this->filename === null) {
                    $this->filename = urldecode(basename($matches[1]));
                }

                if (strpos($matches[1], '://') === false) {
                    $matches[1] = qualify_url($matches[1], $url, true);
                }

                if ($this->no_redirect) {
                    $text = null;
                    $this->download_url = $matches[2];
                } else {
                    $_options = $options;
                    unset($_options['post_params']);
                    $inner_request = _cms_http_request($matches[2], $_options);
                    $text = $this->copy_from_other($inner_request, $this);
                }

                return $text;
            }

            if (preg_match("#^Location: (.*)\r\n#i", $header, $matches) != 0) {
                if ($this->filename === null) {
                    $this->filename = urldecode(basename($matches[1]));
                }

                if (strpos($matches[1], '://') === false) {
                    $matches[1] = qualify_url($matches[1], $url, true);
                }

                if (($matches[1] != $url) && (preg_match('#^3\d\d$#', $this->message) != 0)) {
                    if ($this->no_redirect) {
                        $text = null;
                        $this->download_url = $matches[1];
                    } else {
                        $_options = $options;
                        unset($_options['post_params']);
                        $inner_request = _cms_http_request($matches[1], $_options);
                        $text = $this->copy_from_other($inner_request, $this);
                    }

                    return $text;
                }
            }
        }

        // Receive body
        if ($this->curl_body === null) {
            $this->curl_body = '';
        }
        if ((!in_array($this->message, array('200', '201'))) && (!$this->ignore_http_status)) {
            $this->curl_body = null;
        }

        return $this->curl_body;
    }

   /**
    * Callback for receiving cURL headers.
    *
    * @param  resource $ch cURL resource handle
    * @param  string $header Header
    * @return integer Length of header
    *
    * @ignore
    */
   protected function file_curl_headers($ch, $header)
   {
       $this->curl_headers[] = $header;
       return strlen($header);
   }

   /**
    * Callback for receiving a part of the cURL body.
    *
    * @param  resource $ch cURL resource handle
    * @param  string $str Body part
    * @return integer Length of body part
    *
    * @ignore
    */
   protected function file_curl_body($ch, $str)
   {
       if ($this->write_to_file !== null) {
           fwrite($this->write_to_file, $str);
       } else {
           if ($this->curl_body === null) {
               $this->curl_body = '';
           }
           $this->curl_body .= $str;
       }
       return strlen($str);
   }
}

/**
 * Sockets-based HttpDownloader.
 *
 * @package    core
 */
class HttpDownloaderSockets extends HttpDownloader
{
    /**
     * See if this class may run.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return integer The execution priority
     */
    public function may_run_for($url, $options = array())
    {
        $this->url_parts = @parse_url(normalise_idn_url($url));
        $this->read_in_options($options);

        if (isset($this->url_parts['scheme']) && ($this->url_parts['scheme'] == 'http') && (!GOOGLE_APPENGINE) && (php_function_allowed('fsockopen'))) {
            return HttpDownloader::RUN_PRIORITY_MEDIUM;
        }

        return HttpDownloader::RUN_PRIORITY_NO;
    }

    /**
     * Do the inner call using a particular downloader method.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return ?string The data downloaded (null: error)
     */
    protected function _run($url, $options)
    {
        static $has_ctype_xdigit = null;
        if ($has_ctype_xdigit === null) {
            $has_ctype_xdigit = function_exists('ctype_xdigit');
        }

        $errno = 0;
        $errstr = '';

        $proxy = function_exists('get_option') ? get_option('proxy') : null;
        if ($proxy == '') {
            $proxy = null;
        }
        if (($proxy !== null) && ($this->connect_to != 'localhost') && ($this->connect_to != '127.0.0.1')) {
            $proxy_port = get_option('proxy_port');
            $mysock = @fsockopen($proxy, intval($proxy_port), $errno, $errstr, $this->timeout);
        } else {
            $mysock = @fsockopen($this->connect_to, array_key_exists('port', $this->url_parts) ? $this->url_parts['port'] : 80, $errno, $errstr, $this->timeout);
        }

        if ($mysock !== false) {
            if (function_exists('stream_set_timeout')) {
                if (@stream_set_timeout($mysock, intval($this->timeout)) === false) {
                    $mysock = false;
                }
            } elseif (function_exists('socket_set_timeout')) {
                if (@socket_set_timeout($mysock, intval($this->timeout)) === false) {
                    $mysock = false;
                }
            }
        }

        if ($mysock !== false) {
            $url2 = array_key_exists('path', $this->url_parts) ? $this->url_parts['path'] : '/';
            if (array_key_exists('query', $this->url_parts)) {
                $url2 .= '?' . $this->url_parts['query'];
            }

            if (($proxy != '') && ($this->connect_to != 'localhost') && ($this->connect_to != '127.0.0.1')) {
                $out = '';
                $out .= $this->http_verb . ' ' . escape_header($url) . " HTTP/1.1\r\n";
                $proxy_user = get_option('proxy_user');
                if ($proxy_user != '') {
                    $proxy_password = get_option('proxy_password');
                    $out .= 'Proxy-Authorization: Basic ' . base64_encode($proxy_user . ':' . $proxy_password) . "\r\n";
                }
            } else {
                $out = $this->http_verb . ' ' . escape_header($url2) . " HTTP/1.1\r\n";
            }
            $out .= 'Host: ' . $this->url_parts['host'] . "\r\n";
            $out .= $this->get_header_string();
            $out .= $this->raw_payload;
            if (!$this->sent_http_post_content) {
                $out .= 'Connection: Close' . "\r\n\r\n";
            }
            @fwrite($mysock, $out);
            if ($this->put !== null) {
                rewind($this->put);
                while (!feof($this->put)) {
                    $data = @fread($this->put, 1024 * 100);
                    if (($data !== false) && ($data !== null)) {
                        @fwrite($mysock, $data);
                    } else {
                        break;
                    }
                }
            }
            $data_started = false;
            $input = '';
            $input_len = 0;
            $first_fail_time = null;
            $chunked = false;
            $buffer_unprocessed = '';
            $time_init = time();
            while (($chunked) || (!@feof($mysock))) { // @'d because socket might have died. If so fread will will return false and hence we'll break
                $line = @fread($mysock, 32000);
                if (($input === '') && ($time_init + $this->timeout < time())) {
                    $line = false; // Manual timeout
                }
                if ($line === false) {
                    if ((!$chunked) || ($buffer_unprocessed == '')) {
                        break;
                    }
                    $line = '';
                }
                if ($line == '') {
                    if ($first_fail_time !== null) {
                        if ($first_fail_time < time() - 5) {
                            break;
                        }
                    } else {
                        $first_fail_time = time();
                    }
                } else {
                    $first_fail_time = null;
                }
                if ($data_started) {
                    $line = $buffer_unprocessed . $line;
                    $buffer_unprocessed = '';

                    if ($chunked) {
                        if (isset($line[1]) && $line[0] == "\r" && $line[1] == "\n") {
                            $line = substr($line, 2);
                        }

                        $hexdec_chunk_details = '';
                        $chunk_line_length = strlen($line);
                        for ($hexdec_read = 0; $hexdec_read < $chunk_line_length; $hexdec_read++) {
                            $chunk_char = $line[$hexdec_read];
                            if ($chunk_char == "\r") {
                                $chunk_char_is_hex = false;
                            } else {
                                if ($has_ctype_xdigit) {
                                    $chunk_char_is_hex = ctype_xdigit($chunk_char);
                                } else {
                                    $chunk_char_ord = ord($chunk_char);
                                    $chunk_char_is_hex = ($chunk_char_ord >= 48 && $chunk_char_ord <= 57 || $chunk_char_ord >= 65 && $chunk_char_ord <= 90 || $chunk_char_ord >= 97 && $chunk_char_ord <= 122);
                                }
                            }
                            if ($chunk_char_is_hex) {
                                $hexdec_chunk_details .= $chunk_char;
                            } else {
                                break;
                            }
                        }
                        if ($hexdec_chunk_details == '') { // No data
                            continue;
                        }
                        $chunk_end_pos = strpos($line, "\r\n");
                        if ($chunk_end_pos === false) {
                            $buffer_unprocessed = $line;
                            continue;
                        }
                        $amount_wanted = hexdec($hexdec_chunk_details);
                        $amount_available = $chunk_line_length - ($chunk_end_pos + 2);
                        if ($amount_available < $amount_wanted) { // Chunk was more than what we grabbed, so we need to iterate more (more fread) to parse
                            $buffer_unprocessed = $line;
                            continue;
                        }
                        $buffer_unprocessed = substr($line, $chunk_end_pos + 2 + $amount_wanted); // May be some more extra read
                        $line = substr($line, $chunk_end_pos + 2, $amount_wanted);
                        if ($line == '') {
                            break; // Terminating chunk
                        }

                        $input_len += $amount_wanted;
                    } else {
                        $input_len += strlen($line);
                    }

                    if ($this->write_to_file === null) {
                        $input .= $line;
                    } else {
                        fwrite($this->write_to_file, $line);
                    }

                    if (($this->byte_limit !== null) && ($input_len >= $this->byte_limit)) {
                        $input = substr($input, 0, $this->byte_limit);
                        break;
                    }
                } elseif ($line != '') {
                    $old_line = $line;
                    $lines = explode("\r\n", $line);

                    $tally = 0;
                    foreach ($lines as $lno => $line) {
                        $line .= "\r\n";

                        $tally += strlen($line);

                        $matches = array();
                        if (preg_match("#Transfer-Encoding: chunked\r\n#i", $line, $matches) != 0) {
                            $chunked = true;
                        }

                        $this->read_in_headers($line);

                        if (preg_match("#^Refresh: (\d*);(.*)\r\n#i", $line, $matches) != 0) {
                            if ($this->filename === null) {
                                $this->filename = urldecode(basename($matches[1]));
                            }

                            @fclose($mysock);

                            if (strpos($matches[1], '://') === false) {
                                $matches[1] = qualify_url($matches[1], $url, true);
                            }

                            if ($this->no_redirect) {
                                $text = null;
                                $this->download_url = $matches[2];
                            } else {
                                $_options = $options;
                                unset($_options['post_params']);
                                $inner_request = _cms_http_request($matches[2], $_options);
                                $text = $this->copy_from_other($inner_request, $this);
                            }

                            return $text;
                        }

                        if (preg_match("#^Location: (.*)\r\n#i", $line, $matches) != 0) {
                            if ($this->filename === null) {
                                $this->filename = urldecode(basename($matches[1]));
                            }

                            if (strpos($matches[1], '://') === false) {
                                $matches[1] = qualify_url($matches[1], $url, true);
                            }

                            if ($matches[1] != $url) {
                                if (($matches[1] != $url) && (preg_match('#^3\d\d$#', $this->message) != 0)) {
                                    @fclose($mysock);

                                    if ($this->no_redirect) {
                                        $text = null;
                                        $this->download_url = $matches[1];
                                    } else {
                                        $_options = $options;
                                        unset($_options['post_params']);
                                        $inner_request = _cms_http_request($matches[1], $_options);
                                        $text = $this->copy_from_other($inner_request, $this);
                                    }

                                    return $text;
                                }
                            }
                        }

                        if (preg_match("#HTTP/(\d*\.\d*) (\d*) #", $line, $matches) != 0) {
                            // 200=Ok
                            // 301/302/307=Redirected: Not good, we should not be here
                            // 401/403=Unauthorized
                            // 404=Not found
                            // 400/500=Internal error
                            // 405=Method not allowed

                            $this->message = $matches[2];

                            switch ($this->message) {
                                case '200':
                                case '201':
                                    // Good
                                    break;

                                case '301':
                                case '302':
                                case '307':
                                    // We'll expect a location header
                                    break;

                                case '401':
                                case '403':
                                    if (!$this->ignore_http_status) {
                                        @fclose($mysock);

                                        if ($this->trigger_error) {
                                            warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNAUTHORIZED', escape_html($url)), false, true);
                                        } else {
                                            $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNAUTHORIZED', escape_html($url));
                                        }

                                        return null;
                                    }
                                    break;

                                case '404':
                                    if (!$this->ignore_http_status) {
                                        @fclose($mysock);

                                        if ($this->trigger_error) {
                                            warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_NOT_FOUND', escape_html($url)), false, true);
                                        } else {
                                            $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_NOT_FOUND', escape_html($url));
                                        }

                                        return null;
                                    }
                                    break;

                                case '400':
                                case '429':
                                case '500':
                                    if (!$this->ignore_http_status) {
                                        @fclose($mysock);

                                        if ($this->trigger_error) {
                                            warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_SERVER_ERROR', escape_html($url)), false, true);
                                        } else {
                                            $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_SERVER_ERROR', escape_html($url));
                                        }

                                        return null;
                                    }
                                    break;

                                case '405':
                                    if ($this->byte_limit == 0 && !$this->no_redirect && empty($this->post_params)) { // Try again as non-HEAD request if we just did a HEAD request that got "Method not allowed"
                                        @fclose($mysock);

                                        if ($this->no_redirect) {
                                            $text = null;
                                            $this->download_url = $matches[1];
                                        } else {
                                            $_options = $options;
                                            $_options['byte_limit'] = 1;
                                            $inner_request = _cms_http_request($matches[1], $_options);
                                            $text = $this->copy_from_other($inner_request, $this);
                                        }

                                        return $text;
                                    }

                                default:
                                    if (!$this->ignore_http_status) {
                                        @fclose($mysock);

                                        if ($this->trigger_error) {
                                            warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNKNOWN', escape_html($url), escape_html($this->message)), false, true);
                                        } else {
                                            $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_STATUS_UNKNOWN', escape_html($url), escape_html($this->message));
                                        }

                                        return null;
                                    }
                                    break;
                            }
                        }

                        if ($line == "\r\n") {
                            $data_started = true;
                            $buffer_unprocessed = substr($old_line, $tally);
                            if ($buffer_unprocessed === false) {
                                $buffer_unprocessed = '';
                            }
                            break;
                        }
                    }
                }
            }

            // Process any non-chunked extra buffer (chunked would have been handled in main loop)
            if (!$chunked) {
                if ($buffer_unprocessed != '') {
                    if ($this->write_to_file === null) {
                        $input .= $buffer_unprocessed;
                    } else {
                        fwrite($this->write_to_file, $buffer_unprocessed);
                    }
                    $input_len += strlen($buffer_unprocessed);
                    if (($this->byte_limit !== null) && ($input_len >= $this->byte_limit)) {
                        $input = substr($input, 0, $this->byte_limit);
                    }
                }
            }

            @fclose($mysock);

            if (!$data_started) {
                if ($this->byte_limit === 0) {
                    return '';
                }

                if ($this->trigger_error) {
                    warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_NO_SERVER', escape_html($url)), false, true);
                } else {
                    $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_NO_SERVER', escape_html($url));
                }
                $this->message = 'no-data';


                return null;
            }

            $size_expected = $this->download_size;
            if ($this->byte_limit !== null) {
                if ($this->byte_limit < $this->download_size) {
                    $size_expected = $this->byte_limit;
                }
            }
            if ($input_len < $size_expected) {
                if ($this->trigger_error) {
                    warn_exit(do_lang_tempcode('HTTP_DOWNLOAD_CUT_SHORT', escape_html($url), escape_html(integer_format($size_expected)), escape_html(integer_format($input_len))), false, true);
                } else {
                    $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_CUT_SHORT', escape_html($url), escape_html(integer_format($size_expected)), escape_html(integer_format($input_len)));
                }
                $this->message = 'short-data';

                return $input;
            }

            return $input;
        }

        $errstr = cms_error_get_last();
        if ($this->trigger_error) {
            if ($errstr == '') {
                $errstr = strval($errno);
            }
            $error = do_lang_tempcode('_HTTP_DOWNLOAD_NO_SERVER', escape_html($url), escape_html($errstr));
            warn_exit($error, false, true);
        } else {
            $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_NO_SERVER', escape_html($url));
        }
        $this->message = 'could not connect to host'; // Could append  (' . $errstr . ') but only when debugging because we use this string like a constant in some places

        return null;
    }
}

/**
 * File-wrapper-based HttpDownloader.
 *
 * @package    core
 */
class HttpDownloaderFileWrapper extends HttpDownloader
{
    /**
     * See if this class may run.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return integer The execution priority
     */
    public function may_run_for($url, $options = array())
    {
        return HttpDownloader::RUN_PRIORITY_LOW;
    }

    /**
     * Do the inner call using a particular downloader method.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return ?string The data downloaded (null: error)
     */
    protected function _run($url, $options)
    {
        // PHP streams method
        //  Imperfect, does not support $this->download_url
        $errno = 0;
        $errstr = '';
        if (($errno != 110) && (($errno != 10060) || (ini_get('default_socket_timeout') == '1')) && ((ini_get('allow_url_fopen') == '1') || (php_function_allowed('ini_set')))) {
            cms_ini_set('allow_url_fopen', '1');

            $this->timeout_before = ini_get('default_socket_timeout');
            cms_ini_set('default_socket_timeout', strval($this->timeout));

            if ($this->put !== null) {
                $this->raw_payload .= file_get_contents($this->put_path);
            }

            $crt_path = get_file_base() . '/data/curl-ca-bundle.crt';

            $verifypeer_enabled =
                $this->verifypeer_enabled &&
                !$this->do_ip_forwarding &&
                ((!function_exists('get_value')) || (get_value('disable_ssl_for__' . $this->url_parts['host']) === '0'));

            $opts = array(
                'http' => array(
                    'method' => $this->http_verb,
                    'header' => rtrim((($this->url_parts['host'] != $this->connect_to) ? ('Host: ' . $this->url_parts['host'] . "\r\n") : '') . $this->get_header_string()),
                    'content' => $this->raw_payload,
                    'follow_location' => $this->no_redirect ? 0 : 1,
                    'ignore_errors' => $this->ignore_http_status,
                    'ssl' => array(
                        'verify_peer' => $verifypeer_enabled,
                        'verify_peer_name' => $verifypeer_enabled,
                        'cafile' => $crt_path,
                        'SNI_enabled' => true,
                        'ciphers' => 'TLSv1',
                    ),
                ),
            );

            if (is_string($this->ua)) {
                $opts['http']['user_agent'] = $this->ua;
            }

            $proxy = function_exists('get_option') ? get_option('proxy') : '';
            if ($proxy != '') {
                $port = get_option('proxy_port');
                $proxy_user = get_option('proxy_user');
                if ($proxy_user != '') {
                    $proxy_password = get_option('proxy_password');
                    $opts['http']['proxy'] = 'tcp://' . $proxy_user . ':' . $proxy_password . '@' . $proxy . ':' . $port;
                } else {
                    $opts['http']['proxy'] = 'tcp://' . $proxy . ':' . $port;
                }
            }

            $context = stream_context_create($opts);

            if (($this->byte_limit === null) && ($this->write_to_file === null)) {
                if ($this->trigger_error) {
                    push_suppress_error_death(true); // We have to use this rather than '@' because stream errors don't go into cms_error_get_last() always and thus this is the only way to let those show (as logged/attached messages)
                    $read_file = file_get_contents($this->connecting_url, false, $context);
                    pop_suppress_error_death();
                } else {
                    $read_file = @file_get_contents($this->connecting_url, false, $context);
                }
            } else {
                if ($this->trigger_error) {
                    push_suppress_error_death(true); // We have to use this rather than '@' because stream errors don't go into cms_error_get_last() always and thus this is the only way to let those show (as logged/attached messages)
                    $_read_file = fopen($this->connecting_url, 'rb', false, $context);
                    pop_suppress_error_death();
                } else {
                    $_read_file = @fopen($this->connecting_url, 'rb', false, $context);
                }
                if ($_read_file !== false) {
                    $read_file = '';
                    while ((!feof($_read_file)) && (($this->byte_limit === null) || (strlen($read_file) < $this->byte_limit))) {
                        $read_file .= fread($_read_file, 1024);
                        if ($this->write_to_file !== null) {
                            fwrite($this->write_to_file, $read_file);
                            $read_file = '';
                        }
                    }
                    fclose($_read_file);
                } else {
                    $read_file = false;
                }
            }
            if (($this->byte_limit !== null) && ($read_file !== false) && ($read_file != ''/*substr would fail with false*/)) {
                $read_file = substr($read_file, 0, $this->byte_limit);
            }

            cms_ini_set('allow_url_fopen', '0');
            cms_ini_set('default_socket_timeout', $this->timeout_before);

            if (isset($http_response_header)) {
                foreach ($http_response_header as $header) {
                    $this->read_in_headers($header . "\r\n");
                }
            }

            if ($read_file !== false) {
                return $read_file;
            }
        }

        $errstr = cms_error_get_last();
        if ($this->trigger_error) {
            if ($errstr == '') {
                $errstr = strval($errno);
            }
            $error = do_lang_tempcode('_HTTP_DOWNLOAD_NO_SERVER', escape_html($url), escape_html($errstr));
            warn_exit($error, false, true);
        } else {
            $this->message_b = do_lang_tempcode('HTTP_DOWNLOAD_NO_SERVER', escape_html($url));
        }
        $this->message = 'could not connect to host'; // Could append  (' . $errstr . ') but only when debugging because we use this string like a constant in some places

        return null;
    }
}

/**
 * Filesystem-wrapper-based HttpDownloader.
 *
 * @package    core
 */
class HttpDownloaderFilesystem extends HttpDownloader
{
    /**
     * See if this class may run.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return integer The execution priority
     */
    public function may_run_for($url, $options = array())
    {
        $this->url_parts = @parse_url(normalise_idn_url($url));
        $this->read_in_options($options);

        $faux = function_exists('get_value') ? get_value('http_faux_loopback') : null;
        if (($faux !== null) && ($faux != '') && ($this->post_params === null) && ($this->files == array())) { // NB: Does not support cookies, accept headers, referers
            if (substr($faux, 0, 1) != '#') {
                $faux = '#' . $faux . '#i';
            }
            if (preg_match($faux, $url) != 0) {
                return HttpDownloader::RUN_PRIORITY_VERY_HIGH;
            }
        }

        return HttpDownloader::RUN_PRIORITY_NO;
    }

    /**
     * Do the inner call using a particular downloader method.
     *
     * @param  URLPATH $url The URL to download
     * @param  array $options Map of options (see the properties of the HttpDownloader class for what you may set)
     * @return ?string The data downloaded (null: error)
     */
    protected function _run($url, $options)
    {
        $parsed = parse_url(normalise_idn_url($url));
        $parsed_base_url = parse_url(get_custom_base_url());
        $file_base = get_custom_file_base();
        $file_base = preg_replace('#' . preg_quote(urldecode($parsed_base_url['path'])) . '$#', '', $file_base);
        $file_path = $file_base . urldecode($parsed['path']);

        if ((php_function_allowed('escapeshellcmd')) && (php_function_allowed('shell_exec')) && (substr($file_path, -4) == '.php')) {
            $cmd = 'DOCUMENT_ROOT=' . cms_escapeshellarg(dirname(get_file_base()));
            $cmd .= ' PATH_TRANSLATED=' . cms_escapeshellarg($file_path);
            $cmd .= ' SCRIPT_NAME=' . cms_escapeshellarg($file_path);
            if (is_string($this->ua)) {
                $cmd .= ' HTTP_USER_AGENT=' . cms_escapeshellarg($this->ua);
            }
            $cmd .= ' QUERY_STRING=' . cms_escapeshellarg($parsed['query']);
            $cmd .= ' HTTP_HOST=' . cms_escapeshellarg($parsed['host']);
            $cmd .= ' ' . escapeshellcmd(find_php_path(true)) . ' ' . cms_escapeshellarg($file_path);
            $contents = shell_exec($cmd);
            $split_pos = strpos($contents, "\r\n\r\n");
            if ($split_pos !== false) {
                $_headers = explode("\r\n", substr($contents, 0, $split_pos));
                foreach ($_headers as $line) {
                    $this->read_in_headers($line);
                }
                $contents = substr($contents, $split_pos + 4);
            }
        } else {
            if ($this->trigger_error) {
                $contents = file_get_contents($file_path);
            } else {
                $contents = @file_get_contents($file_path);
            }

            require_code('mime_types');
            require_code('files');
            $this->download_mime_type = get_mime_type(get_file_extension($file_path), true);
            $this->download_size = filesize($file_path);
            $this->download_mtime = filemtime($file_path);
            $this->message = '200';
            $this->filename = basename($file_path);
        }

        if ($this->byte_limit !== null) {
            $contents = substr($contents, 0, $this->byte_limit);
        }

        if ($this->write_to_file !== null) {
            fwrite($this->write_to_file, $contents);
            return '';
        }
        return $contents;
    }
}
