[title sub="Written by Chris Graham (ocProducts)"]Code Book, part 2 (Front-end)[/title]

&laquo; Return to [page="_SEARCH:codebook"]Code Book table of contents[/page]

[contents][/contents]

[title="2"]Front-end[/title]

[title="3"]Standard language strings you can re-use[/title]

The following language strings from [tt]global.ini[/tt] and [tt]critical_errors.ini[/tt] are commonly reused:
 - Nothing here: [tt]MISSING_RESOURCE[/tt], [tt]NO_ENTRIES[/tt], [tt]NO_CATEGORIES[/tt], [tt]NONE[/tt], [tt]NONE_EM[/tt]
 - Actions: [tt]PROCEED[/tt], [tt]SAVE[/tt], [tt]SET[/tt], [tt]CHOOSE[/tt], [tt]USE[/tt], [tt]ADD[/tt], [tt]EDIT[/tt], [tt]DELETE[/tt], [tt]SEND[/tt], [tt]VIEW[/tt], [tt]MORE[/tt], [tt]BROWSE[/tt], [tt]_JOIN[/tt], [tt]_LOGIN[/tt]
 - Choices and records: [tt]YES[/tt], [tt]NO[/tt], [tt]EXISTING[/tt], [tt]NEW[/tt], [tt]OLD[/tt]
 - Users and usergroups: [tt]SUBMITTER[/tt], [tt]USERNAME[/tt], [tt]PASSWORD[/tt], [tt]GROUP[/tt], [tt]_USERGROUP[/tt], [tt]BY[/tt], [tt]BY_SIMPLE[/tt], [tt]GUEST[/tt], [tt]MEMBER[/tt]
 - URLs: uploads and thumbnails: [tt]URL[/tt], [tt]IMAGE_URL[/tt], [tt]UPLOAD[/tt], [tt]THUMBNAIL[/tt]
 - Resources: [tt]PAGE[/tt], [tt]ENTRY[/tt], [tt]CATEGORY[/tt]
 - Table columns/fields, Identifiers: [tt]IDENTIFIER[/tt], [tt]CODENAME[/tt], [tt]TITLE[/tt], [tt]NAME[/tt]
 - Table columns/fields, Properties: [tt]SIZE[/tt], [tt]DATE[/tt], [tt]DATE_TIME[/tt], [tt]TYPE[/tt], [tt]VALIDATED[/tt]
 - Table columns/fields, Other: [tt]AMOUNT[/tt], [tt]FROM[/tt], [tt]TO[/tt], [tt]REASON[/tt], [tt]PARAMETER_A[/tt], [tt]PARAMETER_B[/tt]
 - Rating, sorting, browsing and results: [tt]RATING[/tt], [tt]SORT[/tt], [tt]SORT_BY[/tt], [tt]RESULT[/tt], [tt]_RESULTS[/tt], [tt]START[/tt], [tt]DONE[/tt], [tt]ROOT[/tt], [tt]NEXT[/tt], [tt]PREVIOUS[/tt]

[title="3"]Templates and themes[/title]

Template files are stored on disk, and are defined with the standard "override system" of Composr; as well as this, though, a theme only has to define those templates and CSS files which have been changed from the [tt]default[/tt] theme. Search, parsing, and applying linguistic translation, to templates like this would not be efficient, so Composr compiles the templates upon first-use.

The ultimate compilation target for templates is "serialised tempcode"; if the template is cached as this, it will be loaded directly into memory, and it will then be bound with the parameters of the template (for example, a download box template might take the download name and URL as parameters).

Tempcode is Composr's template programming language. On the simplest level, it provides a substitution mechanism so that parameters and global symbols (like the current user's username, or the time) can be inserted into a template. It also serves as a complete programming language with a powerful set of control mechanisms.

[title="3"]Tempcode syntax[/title]

The syntax for Tempcode (the Composr language used for controlling template output) has the following basic syntax:
 - [tt]{X}[/tt] means "Insert parameter X" (parameters are essentially variables which are passed into the template by the PHP code).
 - [tt]{!X}[/tt] means "Insert language string X".
 - [tt]{!X,BLAH}[/tt] means "Insert language element X with parameter BLAH". BLAH will usually be a parameter itself, so it might look like: [tt]{!X,BLAH,{SOME_PARAM}}[/tt]. (often language strings will have a place for such a parameter, for instance: [tt]SUBMITTED_BY=Submitted by {1}[/tt])
 - [tt]{$X}[/tt] means "Insert symbol X". The symbols are not PHP variables (although the syntax is similar, because it is a similar concept). An example of a symbol is [tt]BASE_URL[/tt] (so to use this write [tt]{$BASE_URL}[/tt]). Symbols can also be used to perform functions, such as equality checks.
 - [tt]{+START,BLAH}...{+END}[/tt] means "Wrap (...) with a directive named BLAH". A directive can be anything that does something to the code it wraps. There are a number of directives that you may use, including output filters such as [tt]IF[/tt], loops, and boxes.

A full description of the Tempcode language is available in the [page="_SEARCH:tut_tempcode"]Tempcode programming[/page] tutorial. Read the Escaping section careful because it is extremely important for security.

[title="3"]WCAG notes[/title]

WCAG is the standard accessibility standard. Imagine, for example, a blind user using a website.

Adherence to the following guidelines can't be automatically detected, so need to be checked manually in your XHTML:
 - [color="#AA2222"]When plugins are used, info about it must be displayed[/color]
 - [color="#AA2222"]When an appropriate markup language exists, use markup rather than images to convey information.[/color]
 - [color="#AA2222"]Mark up lists and list items properly.[/color]
 - [color="#AA2222"]Ensure that all information conveyed with color is also available without color, for example from context or markup.[/color]
 - [color="#AA2222"][tt]<blockquote>[/tt] may not used for non-quoting[/color]

The following guidelines must be adhered to by webmasters themselves:
 - [color="#AA2222"]Until user agents allow users to freeze moving content, avoid movement in pages and Until user agents allow users to control flickering, avoid causing the screen to flicker. By default, nothing flickers, but Comcode allows it. It's a question of whether a site is designed to be accessible for all, or 'fancy' for the majority[/color]
 - [color="#AA2222"]Alternatives given to multimedia content[/color]
 - [color="#AA2222"]Use the clearest and simplest language appropriate for a site's content.[/color]
 - [color="#AA2222"]Divide large blocks of information into more manageable groups where natural and appropriate.[/color]
 - [color="#AA2222"]Specify the expansion of each abbreviation or acronym in a document where it first occurs.[/color]
 - [color="#AA2222"]Place distinguishing information at the beginning of headings, paragraphs, lists, etc.[/color]

[title="3"]The Theme Wizard[/title]

Composr's default CSS uses equations to define colours, all defined against a seed colour. This allows us to define a large harmonious colour scheme programmatically, and thus allows the Theme Wizard to work (recalculating the colours against a different seed colour). It saves themers an enormous amount of time, as manually redefining each colour would be very time consuming, let alone recreating all the theme images within the colour scheme.

Equations look like this in the CSS...
[code="CSS"]
{$THEMEWIZARD_COLOR,#d91522,red_highlight_text,80% FF0000 + 20% seed}
...

span.red-alert, a.red-alert, strong.red-alert, em.red-alert {
    color: {$GET,red_highlight_text};
    ...
}
[/code]

The equations are calculated by an inference chain system. In other words, one equation may reference a colour defined in another equation. The Theme Wizard supports various arithmetically manipulates of colours, using colour science. Any colours defined in [tt]global.css[/tt] may be referenced in any of the other CSS files.

If you are creating a new theme, or just working on a particular site, there is no need to use the Theme Wizard colour system when you add new CSS rules, or change existing ones. Of course because your theme will be derived from the default theme it will still have the Theme Wizard equations in it, coded against the particular seed colour you choose when you created your theme (or the default one if you didn't use the Theme Wizard) -- but that's just to start you off and does not need to be maintained by you. Just embed your own colours directly into the CSS like you normally would, and replace any default equations that you want to. Even if you want the Theme Wizard to work with your theme, the alternative "HSV-shift" Theme Wizard method doesn't require equations to be defined.

If you are adding features to the standard Composr, you must make use of Theme Wizard colours. Almost always you will find there is a colour defined that is appropriate for you to use (see the big collection of them toward the top of the [tt]global.css[/tt] file). There are also some Commandr commands you can use to search for what the nearest defined colour is to an exact RGB colour. If you do need to define a new colour, do so while maintaining the tidy organisation and naming conventions currently in use.

[title="3"]PNG images[/title]

[media description="" width="250" float="right" framed="0"]data_custom/images/docs/codebook_2/png.png[/media]
As a standard Composr uses 32-bit PNG files over other image types, unless animation is required ([tt].gif[/tt] used instead). Soon will be able to do animation too via [url="APNG"]http://caniuse.com/#feat=apng[/url] though.

We use PNG files because they have the added advantage that they can be 'alpha-blended' for smooth, blended, visuals.

GIF files are:
 - limited to 256 colours
 - only have "binary transparency". so for smooth blending the image itself needs to be "pre-compiled" against the background colour of your website (which may be edited in the CSS, or be different in different areas of the site, so you really don't want pre-compilation assumptions).

JPEG files do not support transparency, and as we prefer to not assume any particular image won't be edited to have transparency, we opt to not use them. Also JPEG has serious problems when images are re-saved, which is a standard event when editing default images. Otherwise we acknowledge JPEG provides superior compression in most normal circumstances.

Besides the lack of animation, there is one further problem with PNG images -- various web browsers, including Microsoft Edge and Safari, are incompatible with the settings used by Photoshop to save them. The colours are always slightly wrong -- noticeable if the images need to line up with background colours defined in the CSS. The problem is caused by the browsers not supporting PNG gamma settings properly. Fortunately this problem is solved by passing the images through a free compression-optimisation program called [url="PNGGauntlet"]https://pnggauntlet.com/[/url] (for Windows; use [url="ImageOptim"]https://imageoptim.com/mac[/url] on a Mac), which is worth doing anyway as it provides significant loss-less file-size savings over what Photoshop can do. Instructions for using PNG Gauntlet:
 - Backup your images, just in case something goes wrong.
 - Download PNGGauntlet and run it. Select RGB+Alpha as the output type, and minimise depth reduction. Do not preserve gamma information.
 - Tick (check) the "Overwrite Original Files" checkbox.
 - In the file selection dialogue, choose to only show PNG files. We should ONLY be optimising these, otherwise PNGGauntlet will convert any GIFs and JPEGs to PNGs.
 - Start optimi[sz]ing. Choose your files. You must do the optimisation one directory at a time because PNGGauntlet will erase the task list each time you click "Choose files to optimize".
 - Once done, you may need to tell Windows to reset the permissions in the images folder from that of the parent folder (because PNGGauntlet will copy the compressed image in from a temp dir, with the permissions of that temp dir). If you don't do this, you may find you get a permission denied when viewing the images and lots of red crosses.

[title="3"]JavaScript[/title]

JavaScript is separate from Java, and built into web browsers directly. It is used to provide an interactive element to the user's experience in their web browser. Composr has a loose framework for producing templates that use JavaScript.

[title="3"]JavaScript libraries[/title]

Composr has an inbuilt set of JavaScript libraries, which are split across a number of JavaScript template files in the [tt]javascript[_custom][/tt] template directory. The core library that is loaded onto every screen is named just [tt]global.js[/tt]. This core library is very general and doesn't know about Composr's individual modules -- it is a general-purpose library to provide functionality usable anywhere. Most of the other JavaScript libraries are specific to individual modules (e.g. the [tt]chat[/tt] module uses [tt]chat.js[/tt]) or to specific aspects of Composr (e.g. the Comcode editing interface uses [tt]editing.js[/tt]). There are a few additional general purpose JavaScript libraries:
1) [tt]ajax[/tt] -- AJAX call functionality, which should be used for all AJAX code.
2) [tt]dragdrop[/tt] -- A drag and drop library (do not use this unless drag & drop really is the best way to build an interface, which is very rare)
3) [tt]jquery[/tt] -- Bundled jQuery library, used on some screens (but not usually included as a cross-site dependency).
4) [tt]transitions[/tt] -- Provide various transition/animation effects.

To flag a javascript file to be loaded up, use the [tt]require_javascript[/tt] API command in the PHP code. For example, if you wanted to load up the JavaScript defined in an [tt]example.js[/tt] template, use:
[code="PHP"]
require_javascript('example');
[/code]
This command is usually best placed:
1) in screen functions if it is not used by all screens in your module
2) or, in the [tt]run[/tt] function if it is used by all/most screens in your module

Alternatively, you can load JavaScript from a template with a command like:
[code="Tempcode"]
{$REQUIRE_JAVASCRIPT,example}
[/code]

You may add new JavaScript templates as needed. The instructions are the same as integrating a third-party library:
See the [page="_SEARCH:tut_integration"]Integration of Composr and other installed scripts/applications[/page] tutorial.

When writing new JavaScript code try to make good use of the existing functions that are defined in whatever JavaScript you already have included. For example, use the standard cookie manipulation functions and standard AJAX functions, rather than making new ones. If existing functions are not sufficient consider improving those functions.

In Composr, JavaScript libraries are automatically minified to save on bandwidth, unless [tt]&keep_minify=0[/tt] is in the URL (very useful for debugging).

[title="3"]Useful Composr JavaScript functions[/title]

 - [b]Escaping[/b]: [tt]$cms.filter.html[/tt], [tt]$cms.filter.comcode[/tt]
 - [b]Cookies[/b]: [tt]$cms.setCookie[/tt], [tt]$cms.readCookie[/tt]
 - [b]Introspection[/b]: [tt]$dom.$$[/tt], [tt]$dom.css[/tt], [tt]$cms.browserMatches[/tt]
 - [b]Calling up dependencies[/b]: [tt]$cms.loadSnippet[/tt], [tt]$cms.requireJavascript[/tt]
 - [b]Viewport[/b]: [tt]$dom.getWindowWidth[/tt], [tt]$dom.getWindowHeight[/tt], [tt]$dom.getWindowScrollHeight[/tt], [tt]get_window_scroll_x[/tt], [tt]get_window_scroll_y[/tt]
 - [b]Element positioning[/b]: [tt]$dom.findPosX[/tt], [tt]$dom.findPosY[/tt], [tt]find_width[/tt], [tt]find_height[/tt]
 - [b]Tooltips[/b]: [tt]$cms.ui.activateTooltip[/tt]
 - [b]Misc[/b]: [tt]$dom.on[/tt]
 - [b]HTML manipulation[/b]: [tt]$dom.html[/tt]
 - [b]AJAX[/b]: [tt]$cms.doAjaxRequest[/tt]
 - [b]Animation[/b]: [tt]$cms.ui.toggleableTray[/tt], [tt]$dom.smoothScroll[/tt], transitions.js: [tt]$dom.fadeIn[/tt]

[title="3"]JavaScript event handlers[/title]

Add in JavaScript event handlers to your HTML normally as required. For example, to make a pop-up window link:
[code="HTML"]
<a href="{BASE_URL*}/popup.htm" onclick="window.open(this.getAttribute('href'));">Click me</a>
[/code]
It's acceptable to write inline event handler code like this as long as it doesn't get too long.

Sometimes it is not appropriate to add an event directly to an HTML node, usually for one of these reasons:
 - You can't always make the assumption that a node will only have a single event handler
 - Sometimes event handlers need putting on generic events such as [tt]onload[/tt]
 - Sometimes you want to add event handlers from inside JavaScript code, on-the-fly
In these circumstances you can add the event to an HTML node indirectly by using the [tt]add_event_listener_abstract[/tt] function. This function works consistently across browsers (so long as you don't try and use [tt]this[/tt] inside the event handler code).

[title="3"]Inline JavaScript[/title]

It's acceptable to use inline JavaScript (the [tt]script[/tt] tag) if it's only a short amount of code. This is a useful technique:
1) if you want to pass template parameters directly into JavaScript variables
2) or, if you need the code to run as soon as the screen loads

You should use 'CDATA' for your [tt]<script>[/tt] tag, like:
[code="HTML"]
<script>// <![CDATA[
	...
//]]></script>
[/code]

It is important that:
[list]
[*] You use the "//" bits. Usually Composr will be running as HTML even though it is marked-up as XHTML (this is a little known fact but is the case for almost websites out there, whatever they are running). HTML interprets everything in the script tag as CDATA automatically so everything inside there is parsed as JavaScript; the "//" bits are simply JavaScript comments to stop the CDATA bits being interpreted as JavaScript code.
[*] You should actually use CDATA so the document does conform as XHTML.
[*] You should not put it all on one line, because then the JavaScript line-comment will end up commenting all the code out and nothing will happen.
[*] Don't use any Composr JavaScript except for JavaScript in the main [tt]global.js[/tt] library, unless you have put it inside a [tt]$dom.ready[/tt] promise callback function, like:
[code="JavaScript"]
$dom.ready.then(function () { ... });
[/code]
[*] This is because Composr does not want to pre-load any more JavaScript library code than is necessary via loading it in <head> (it stops the page rendering at all until the files have been downloaded), and we can't assume the order JavaScript will be loaded in compared to the order in which inline code is executed (it changes randomly, and between browsers). By putting our code inside an onload handler we force it to only run after all our dependent JavaScript files have loaded.
[/list]

[title="4"]Example: mixing event handlers, inline JavaScript, and a library[/title]

This is a little example that does something completely pointless. This complex combination of event handlers, inline JavaScript, and a JavaScript library, should only be used if there is a reason for it. If there is no reason, simpler code is better. The complex example is shown here to show how different JavaScript methods can fit together if they need to.

In the template:
[code="HTML"]
<script>// <![CDATA[
/* Store a template parameter into a global variable.
Placing on the window object is the same as setting a global variable.
Writing it like this just makes it more clear it's a global variable which reduces the risk of obscure bugs.
Note the escaping here: It adds escaping for both the string quotes (;) as well as the CDATA section (/). This makes sure the parameter can not be used to create an XSS injection vulnerability. */
window.myTemplateParameter='{MY_TEMPLATE_PARAMETER;/}';
//]]></script>

<a href="#!" onclick="outputMyParameter();">Click me</a>
[/code]

In the JavaScript library (which must have been loaded using [tt]require_javascript[/tt]):
[code="JavaScript"]
function outputMyParameter()
{
	// Output the global variable we made.
	window.alert(window.myTemplateParameter);
}
[/code]

[title="4"]Simpler example[/title]

The above example used global variables which is bad programming practice. I did it because it was a good example, but the following example is much better quality and simpler...

In the template:
[code="HTML"]
<a href="#!" onclick="outputMyParameter('{MY_TEMPLATE_PARAMETER;*}');">Click me</a>
[/code]
In the JavaScript library:
[code="JavaScript"]
function outputMyParameter(message)
{
	window.alert(message);
}
[/code]

[title="3"]Writing AJAX functionality[/title]

AJAX requests allow dynamic updating of webpages by making calls to the web server during the viewing of a web page.

AJAX requests can be either synchronous or asynchronous. A synchronous request runs linearly: JavaScript makes the call and then the browser will wait for the response before resuming execution. An asynchronous request involves a later (at an unknown point) 'call back' to a response handler (the "method") that we would write specially. Technically a synchronous-AJAX request is a contradiction (the 'A' in AJAX means 'asynchronous'), but the way people use the term AJAX means it's best we not worry about this. It's rare for us to use synchronous requests as it can make the browser freeze while it waits.

[title="4"]Detailed steps for writing code involving AJAX[/title]

[list="1"]
[*] [b]Write normal Composr screen[/b]:

We'll assume you already have some working PHP code that calls a template.

[*] [b]Load Composr JavaScript library from your PHP code[/b]:

For adding AJAX functionality, we can use the functions defined in the [tt]ajax.js[/tt] template (in particular, [tt]$cms.doAjaxRequest[/tt]). For using those functions, we should include [tt]ajax[/tt] as a JavaScript dependency using this PHP code:
[code="PHP"]
require_javascript('ajax');
[/code]

[*] [b]Write custom JavaScript code[/b]:

We need our own JavaScript template file to implement our AJAX-tied behaviour, because the code is probably going to be too long to include in-line with the HTML. For our purposes we'll decide it is a JavaScript template named [tt]example.js[/tt].

In our JavaScript template file, we typically define basically two functions if we are writing asynchronous AJAX. One function is for initiating the AJAX event (can be any name you like) and another is to handle the response of the AJAX script (has any name, but it must be passed to the Composr [tt]$cms.doAjaxRequest[/tt] function). If you are writing synchronous AJAX you can pass the null value instead of a function, and the [tt]$cms.doAjaxRequest[/tt] function will respond with the result.

[*] [b]Load custom JavaScript code[/b]:

Our JavaScript code must be loaded up from the PHP code by:
[code="PHP"]
require_javascript('example');
[/code]

[*] [b]Write entry-point script[/b]:

To handle the AJAX request on the server-side we will need to call a new entry-point script. We'll place in the [tt]data/[/tt] folder -- or, if you are writing third-party functionality, it should go into [tt]data_custom/[/tt] instead.

In the [tt]data/<script-name>.php[/tt], we [tt]require_code[/tt] a file that will contain a new PHP function to implement our server-side handler code, and then call that function (and nothing else). We'll describe that in the next step.

Note that the Composr entry-point script code is 99% boilerplate. Only the final few lines are customised, the rest is copy&pasted.

[box="Use entry-point scripts properly"]
[media thumb="0" framed="0" float="right"]data_custom/images/docs/dont.png[/media]
Don't try and omit making an entry-point script by calling [tt]index.php[/tt] directly.

You really do not want all the peripheral implications of a full page load (zone permissions, global HTML wrapper, etc). In other words, you are not going through a zone, you are not using the [tt]do_site[/tt] methodology of loading up a Composr page.
[/box]

[*] [b]Write server-side handler code[/b]:

It is a Composr convention to define our server-side handler function in [tt]sources/ajax.php[/tt], but we don't have to (and shouldn't if it's not a very core AJAX function to Composr). Remember if you are writing third-party functionality it should go into a file under [tt]sources_custom/[/tt] instead.

Our PHP function should return a response in XML (i.e. XML format, with a [tt]text/xml[/tt] mime type) -- or, for the very simplest use-cases, in text format (i.e. with a [tt]text/plain[/tt] mime type). In other words, run the correct [tt]header[/tt] command before anything else. You can only return XHTML if you do it under an [tt]text/plain[/tt] mime type.

Note that you must use XML format in any of these situations:
 - You need to implement error handling and just returning a blank response upon some kind of known error would be insufficient.
 - You need to return structured data.
If in doubt, use XML.

[box="Returning errors"]
The only time in which XHTML is returned with a [tt]text/html[/tt] mime type is if there was some kind of error and Composr outputs an error screen, in which case it would be automatically accompanied with an HTTP status code of '500', and any non-200 status code would prompt the AJAX framework to put out an error message.

If you are writing your own webmaster-friendly error handling then you should put out errors in the XML frame Composr uses (described below), or you should encode your own error passing system into the pay-load data.
[/box]

The XML frame you should output from PHP should be structured as follows:
[code="XML"]
<?xml version="1.0" encoding="charset"?>
<request>
	<result>
		(Your pay-load data goes here. It is likely this is XML,
		with your own specific set of tags,
		but it can be XML-encoded plain-text if you like.)
	</result>
	<message>
		<error>(Some kind of error message that will be put in an alert)</error>
		(Some kind of informational message that will be put in an alert)
	</message>
	<method>
		(JavaScript function name that overrides what was passed to $cms.doAjaxRequest)
	</method>
</request>
[/code]

This example of the full usage. However normally you don't return any method or messages, so you will see real code is usually much simpler, like:
[code="PHP"]
<?php
header('Content-Type: text/xml; charset=' . get_charset());
prepare_for_known_ajax_response(); // Make sure input data is converted, as JavaScript always uses utf-8 even if we are not set to use it
echo '<?xml version="1.0" encoding="' . get_charset() . '"?' . '>';
echo '<request><result>';
$out=do_something_and_get_tempcode();
$out->handle_symbol_preprocessing();
$out->evaluate_echo();
echo xmlentities($out);
echo '</result></request>';
[/code]
[/list]

Once the server has returned a result to the client, it will be processed for handling.
 - For synchronous requests, the result object is returned from [tt]$cms.doAjaxRequest[/tt] linearly (asynchronous requests will return nothing from [tt]$cms.doAjaxRequest[/tt]). Code may then use the [tt]responseText[/tt] and [tt]responseXML[/tt] properties of this as required.
 - For asynchronous requests, the response handler (the [tt]method[/tt]) function is called, with two parameters: [tt]ajax_result_frame[/tt] (the full XML), and [tt]ajax_result[/tt] (the pay-load XML). It is the responsibility for the method function to process the XML in ajax_result (ajax_result_frame is unlikely to be used by the method) -- the code can assume the XML will be valid because HTTP status error handling and XML frame error handling will already have occurred.
There is an implied format contract between the PHP code we wrote and the JavaScript we wrote. In other words, we are not likely to have incompatibilities between the data of the server (PHP) and client (JavaScript) as you will have designed them together. Therefore you don't need to write any special error handling code to make sure the structure returned is correct, unless you've written in your own extra error handling into the pay-load.

Example:
 - Template -- [tt]themes/default/javascript/ajax_people_lists.js[/tt]
 - Data file -- [tt]data/namelike.php[/tt] (calls [tt]namelike_script()[/tt] defined in [tt]sources/ajax.php[/tt])
 - Ajax php script -- [tt]source/ajax.php[/tt]

[box="Debugging"]
[media thumb="0" framed="0" float="right"]data_custom/images/docs/remember.png[/media]
Modern web browsers have excellent debugging capabilities for AJAX.

You can open up development tools and inspect the requests and responses of all AJAX requests that are happening.
[/box]

[title="4"]Object-based callbacks (advanced)[/title]

You can either pass a function to the [tt]$cms.doAjaxRequest[/tt] function as your method, or you can pass an object that has a [tt]response[/tt] function in it. The latter is useful if you want to make your response a neat part of an OOP approach.

[title="3"]Boxes[/title]

Composr uses boxes to show featured areas, including featured content and categories. The concept of boxes comes up in a few system layers:
 - CSS: The [tt].box[/tt] CSS class (and associated CSS classes)
 - Templates: The HTML markup referencing the above
 - Tempcode: The Tempcode [tt]BOX[/tt] directive, for automatically generating box markup (not used much in v9+ due to it adding an unnecessary abstraction layer, but was common in previous versions when the markup was more complex due to a need to support old web browsers)
 - Comcode: The Comcode [tt]box[/tt] tag, used for generating a box from Comcode
 - Content API: The [tt]render_<content-type>_box[/tt] functions, and associated templates that they call up

The rest of this section will focus on how the content API uses boxes...

Almost every kind of content (and category) has an content type hook defined. That content type hook will specify how a box of that content (or category) will be displayed. The convention is that the content type hooks glue themselves to the [tt]render_<content-type>_box[/tt] functions, which glue themselves to particular templates.

So, how do the templates work? Any content type will probably have two main templates used to display it:
1) A box template ([tt]<content_type>_BOX.tpl[/tt]) [what we are discussing here]
2) A screen template ([tt]<content_type>_SCREEN.tpl[/tt])

Box templates are used on category listings, previews, search results, and when picking out content to display with an award. Box templates generally hold the following criteria:
 - Must be surrounding with standard box markup, or mainly consist of a table
 - If it is a box, must have a level 3 header within the box (boxes must not be presented as list elements -- they are headed sections in boxes, and CSS may change the appearance of them if required due to the consistency of the box markup)
 - Will typically involve a title/thumbnail/caption, but it really depends what the content is; the [tt]SIMPLE_PREVIEW_BOX.tpl[/tt] template may be used for a foundation for very simple box layouts where no dedicated template is needed
 - Must support display in both category and standalone contexts
  - Category contexts will not mention the content type or show breadcrumbs
  - Standalone contexts will make it clear enough what the content actually is, rather than merely showing a title/thumbnail/caption; for hierarchically stored content breadcrumbs should be included
 - Must primarily support a fairly minimal raw context, but possibly with the [b]option[/b] to have additional attached bits such as edit links
 - Box templates should look neat, not too generic
 - Box templates should be flexible enough to show in a carousel, in a grid, or as standalone/sequential boxes
 - Box templates for categories should say how many child entries are inside the category

[title="4"]Category listings[/title]

As mentioned in the section above, category listings consist of a run of boxes. Composr has a standard block for displaying runs of boxes, the [tt]main_multi_content[/tt] block. Where possible the module category listing screens will simply glue themselves to an appropriate call to that block with minimal other code (code for breadcrumbs, loading up metadata, checking permissions, providing a wrapper template, etc).

By gluing listings to a block, pagination can work via AJAX because a block is defined neatly as an autonomous region of a page. It also saves lots of code duplication -- we need the blocks anyway so that webmasters have fluidity in how they can lay content out, so it makes sense to centralise around them. Lastly, it creates important consistency and maintains important building blocks as high quality.

However, things aren't always so simple. There are some exceptions because some content listings are not as simple as querying a category/Selectcode-string and displaying the contents. Here are the main cases:
 - the news system allows some quite complex rules about what to display, and uses multiple display types simultaneously. Therefore we have a custom [tt]main_news[/tt] and a [tt]main_news[/tt] block (and also a [tt]side_news_categories[/tt] for organising by date).
 - the gallery system has to aggregate both images and videos. Therefore we have a custom [tt]main_gallery_embed[/tt] block.
 - the calendar system display is organised by date. Therefore we have a custom [tt]side_calendar[/tt] block.
 - the catalogue system comes with a range of available display types, not just boxes. This is because we need to give catalogue authors a wide-palette due to lack of ability to code in any assumptions. Therefore we have a custom [tt]main_cc_embed[/tt] block.
 - the Personal Galleries feature may mean that empty galleries may be left around, and also download galleries need to be skipped.
 - the gallery provides a carousel-mode display type which is inherently module-based.
 - other modules use very fine-tuned listings for display categories/content. For example, the chat lobby shows rooms as a compact list.
 - other modules make custom content queries which don't match up to what the parameters for existing blocks can achieve. For example, the [tt]authors[/tt] module shows what downloads and news belongs to a particular author.

[box float="right" width="20em"]
This abstraction quandary comes up in other places too. Often programmers will try and abstract everything and end up with a mess. For example, Composr CRUD modules define the form structure manually. We could try and automatically generate forms via the semantic database structure we already have -- but for usability we need much more control over how each form will look in every case.
[/box]
There is a constant battle between abstraction, and intuitive interfaces. Not everything can be simplified down to an instance of a common pattern. Therefore Composr abstracts the patterns in layers, and then module/block code will interface with the layer that is compatible with its requirements and fill in the gaps. This minimises code, while maximises the user experience, and allows new unplanned experiences to be created by webmasters who wish to interface with the APIs at various levels. In general, even if a block is not used to display listings, the code required is still minimal due to use of the [tt]render_<content-type>_box[/tt] functions.

[title="4"]Why doesn't Composr just use blocks for everything?[/title]

Some people might also wonder why we have modules to display categories at all. Why is it not entirely fluid, done through putting the blocks where you want them? There are three main answers to this:
1) Content needs a 'home' URL that the system knows, for many reasons (e.g. RSS linkage, XML Sitemaps, notification URLs, ...). It can't reliably second guess this via looking where blocks are.
2) Simplicity! Composr is about having a good website quick, you shouldn't have to understand how to lay out your own skeleton, or do it for each project. Power should be something that is available, but the defaults should be simple.
3) It is difficult to see how blocks could be used to navigate a category tree -- the architecture for this would be really quite complex, considering there is no direct/easy association between URL and the parameters a block takes.

Some people might wonder why entry viewing isn't done via blocks, or really any other code other than category viewing. The reason is that we don't want a huge collection of blocks and lots of extra internal code complexity. So, we solve the issue of wanting to allow fluid site structure via the [tt]main_include_module[/tt] block, which allows you to take a module screen and use it [i]as if it was a block[/i]. Again, we try and represent what is commonly required in the default Composr structure, and coded in the simplest possible way, while also making the system fluid and malleable enough to make changes.

[title="3"]Making theme changes outside Composr[/title]

[media description="" width="250" float="right" framed="0"]data_custom/images/docs/codebook_2/1.jpg[/media]
When you add/edit theme images inside Composr, it makes up a filename. But instead if you make the [tt]themes/<theme>/images_custom[/tt] naming structure match that of [tt]themes/default/images[/tt], then Composr automatically finds them. This is better when working collaboratively with git, or if synching development and live sites, because a new database record is not needed to track the theme image reference.

Generally you should rarely use the Composr inbuilt theming tools when acting as a programmer. Just put the files in the right place and use your text editor to alter the CSS and templates. This makes for a more integrated, programmer-friendly, workflow.

The only caveat with theme images is that if Composr has already searched for it a theme image in your theme, and only found the default one, you'd need to empty the theme_images table to make it search again. That's safe as long as you only add/edit via filesystem and never from inside Composr.

{$SET,tutorial_tags,Development,PHP,Development,CSS,JavaScript,expert}{$SET,tutorial_add_date,Jan 2006}{$SET,tutorial_summary,The programmer's guide for Composr development. Front-end development.}[block]main_tutorial_rating[/block]

[title="2"]Meta-analysis of the code-base[/title]

[title="3"]Language string word count[/title]

Here's a script for if you want to know some basic stats about Composr's English language pack:
[codebox="PHP"]
<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.

 Meta Script:
   Count the number of words in Composr currently
*/

if (!isset($_GET['path'])) {
    exit('Must give a \'path\' parameter');
}
chdir($_GET['path']);

$count = 0;
$strings = 0;
$files = 0;
$path = 'lang/EN/';
$dh = opendir($path);
while (($f = readdir($dh)) !== false) {
    if (substr($f, -4) == '.ini') {
        $files++;
        $lines = file($path . $f);
        foreach ($lines as $line) {
            $bits = explode('=', $line, 2);
            if (count($bits) == 2) {
                $count += count(preg_split('/\s+/', $bits[1]));
                $strings++;
            }
        }
    }
}

header('Content-type: text/plain');

echo number_format($count) . ' words, in ' . number_format($strings) . ' language strings, in ' . number_format($files) . ' files.';
[/codebox]

[title="3"]Top functions[/title]

Here's a script for if you you to found out what are the most common functions used in the Composr PHP code:
[codebox="PHP"]
<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.

 Meta Script:
   Find top functions used in a codebase
*/

header('Content-type: text/plain');

if (isset($_GET['path'])) {
    chdir($_GET['path']);
}

$out = do_dir('.');
$calls = array();
foreach ($out as $file) {
    $code = file_get_contents($file);
    $matches = array();
    $num_matches = preg_match_all('#(\w+)\(#', $code, $matches);
    for ($i = 0; $i < $num_matches; $i++) {
        $call = $matches[1][$i];
        if ($call != 'array') {
            if (!isset($calls[$call])) {
                $calls[$call] = 0;
            }
            $calls[$call]++;
        }
    }
}

arsort($calls);

var_dump($calls);

function do_dir($dir)
{
    $out = array();
    $_dir = ($dir == '') ? '.' : $dir;
    $dh = opendir($_dir);
    if ($dh) {
        while (($file = readdir($dh)) !== false) {
            if (($file{0} != '.') && ($file != 'exports')) {
                if ((is_file($_dir . '/' . $file)) && (substr($file, -4) == '.php')) {
                    $out[] = $_dir . '/' . $file;
                } elseif ((is_dir($_dir . '/' . $file)) && (strpos($file, '_custom') === false) && ($file != 'tracker')) {
                    $out = array_merge($out, do_dir($dir . (($dir != '') ? '/' : '') . $file));
                }
            }
        }
    }
    return $out;
}
[/codebox]
